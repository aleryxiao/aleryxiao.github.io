<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>極楽浄土</title>
  
  <subtitle>フロトの理发店 | @AleryXiao</subtitle>
  <link href="https://aleryxiao.github.io/atom.xml" rel="self"/>
  
  <link href="https://aleryxiao.github.io/"/>
  <updated>2023-01-10T05:29:40.382Z</updated>
  <id>https://aleryxiao.github.io/</id>
  
  <author>
    <name>AleryXiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>想玩的游戏List</title>
    <link href="https://aleryxiao.github.io/Private/c342359b.html"/>
    <id>https://aleryxiao.github.io/Private/c342359b.html</id>
    <published>2023-01-08T03:45:50.000Z</published>
    <updated>2023-01-10T05:29:40.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文字游戏"><a href="#文字游戏" class="headerlink" title="文字游戏"></a>文字游戏</h3><ul><li><p>Clannad</p></li><li><p>克洛诺斯</p></li><li><p>little busters</p></li><li><p>ALTDEUS:Beyond Chronos</p></li><li><p>星空列车与白的旅行</p></li><li><p>绯染天空</p></li><li><p>Ever 17</p></li><li><p>428</p></li><li><p>千恋万花</p></li><li><p>赛博酒保</p></li><li><p>绯色的欠片</p></li><li><p>夏空的独白</p></li><li><p>神なる君と</p></li><li><p>幸运之杖</p></li><li><p>QR社童话系列</p></li></ul><ul><li><p>（2022年汉化）蛇香</p></li><li><p>LicoBiTs-泡沫のユークロニア<br><img src="/../../assets/Pasted%20image%2020230108183723.png"></p></li><li><p>Slow Damage</p></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>杀戮尖塔</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文字游戏&quot;&gt;&lt;a href=&quot;#文字游戏&quot; class=&quot;headerlink&quot; title=&quot;文字游戏&quot;&gt;&lt;/a&gt;文字游戏&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Clannad&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;克洛诺斯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;little</summary>
      
    
    
    
    <category term="Private" scheme="https://aleryxiao.github.io/categories/Private/"/>
    
    
  </entry>
  
  <entry>
    <title>咎狗之血</title>
    <link href="https://aleryxiao.github.io/Tavg/RoseR/ff3273f7.html"/>
    <id>https://aleryxiao.github.io/Tavg/RoseR/ff3273f7.html</id>
    <published>2023-01-07T14:50:02.000Z</published>
    <updated>2023-01-02T19:07:11.095Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Infomation: <a href="https://zh.moegirl.org.cn/%E5%92%8E%E7%8B%97%E4%B9%8B%E8%A1%80">MoeLink</a></p></li><li><p>CV List：</p></li></ul><table><thead><tr><th>姓名</th><th>声优</th><th>角川译名</th><th>身高</th><th>年龄</th></tr></thead><tbody><tr><td>Akira</td><td>先割れスプーン(鸟海浩辅)</td><td>明</td><td>172cm</td><td>18~19岁</td></tr><tr><td>Shiki</td><td>绿川光</td><td>式</td><td>188cm</td><td>21~24岁</td></tr><tr><td>Keisuke</td><td>何武者(杉田智和)</td><td>启介</td><td>178cm</td><td>18~19岁</td></tr><tr><td>Rin</td><td>鬼龙院隼人(福山润)</td><td>凛</td><td>154cm</td><td>-</td></tr><tr><td>源泉</td><td>一条和矢</td><td></td><td>183cm</td><td>40岁+</td></tr><tr><td>NANO</td><td>Prof.紫龙神谷浩史(山崎巧)</td><td></td><td>182cm</td><td>-</td></tr><tr><td>Yukihito</td><td>神谷浩史</td><td></td><td>178cm</td><td>21~24岁</td></tr></tbody></table><p>太猛了，一种在血沼里找糖吃的感觉&amp;……</p>]]></content>
    
    
    <summary type="html">tbc。但是N+C牛逼！</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="RoseR" scheme="https://aleryxiao.github.io/categories/Tavg/RoseR/"/>
    
    
    <category term="N+C" scheme="https://aleryxiao.github.io/tags/N-C/"/>
    
  </entry>
  
  <entry>
    <title>无法打开的黑与金之匙</title>
    <link href="https://aleryxiao.github.io/Tavg/SakuraR/e8c6562f.html"/>
    <id>https://aleryxiao.github.io/Tavg/SakuraR/e8c6562f.html</id>
    <published>2022-12-31T07:26:03.000Z</published>
    <updated>2023-01-02T14:07:00.660Z</updated>
    
    <content type="html"><![CDATA[<p>简评：打开少女的心扉（？）<br>推荐：4&#x2F;5<br>标签：校园</p><p>虽然是老作品但是画风意外地对我胃口&gt;A&lt;</p>]]></content>
    
    
    <summary type="html">TBC 4/5 打开少女的心扉（？）</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="SakuraR" scheme="https://aleryxiao.github.io/categories/Tavg/SakuraR/"/>
    
    
  </entry>
  
  <entry>
    <title>沧海天记</title>
    <link href="https://aleryxiao.github.io/Tavg/Flos/dafa11a.html"/>
    <id>https://aleryxiao.github.io/Tavg/Flos/dafa11a.html</id>
    <published>2022-12-26T14:50:02.000Z</published>
    <updated>2023-01-02T14:01:45.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/2022122622435400.jpg"></p><h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><p>推荐：3&#x2F;5<br>简评：少年的羁绊与神明的羁绊<br>篇幅：不会继续玩了。两条线约12h</p><p>Caution：</p><ul><li>描写男性之间的友谊和羁绊的意思就是真的是友谊和羁绊，不是指女性向分类下属的蔷薇向（。）一点擦边都没有的那种（啊啊啊啊我没法理解一个没有恋爱线的游戏有好感度机制！！）</li><li>决战描写非常的有很多乙女向文字游戏的风格，特点就是非常的回合制，非常的二，非常多的谜之静止帧</li><li>单一主线，根据好感度不同会进入和不同伙伴共同战斗的分支结局，总体上差别不大。不过这条主线写得非常有趣，让玩家甚至无法猜测到下一步会发生什么。</li></ul><p>打完感觉人已经没有感觉了，这到底是怎么回事呢，原来有人打之前根本就没有注意什么叫做真正的女性向——原来就是真正的一点恋爱都没有的意思啊！博主打着打着都要掉小珍珠了……</p><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><p>我真的是忍不了！拜托！你那决战写的是什么东西！？如果有人倒下了，邪神就在旁边看着所谓正派几个人磨磨唧唧一会然后几个人若无其事地继续回合制……邪神完全不够邪好吧，直接挨个击破不行吗，几个小孩就在你的家里乱窜你怎么可能不知道……</p><p>还有你那几个情感丰富的神，太好了，除了邪神，太阳神一家三口我是几乎一点神性都感受不到，这波，这波是人类直接被太阳神一家三口的优柔寡断拖死了……傻白甜月读和他的傻白甜哥哥天照，被邪神忽悠的一愣一愣的就好像没有大脑，哦对你们神是不是确实没有大脑，不好意思啊。</p><p>考虑到神话背景，就不吐槽把神的力量远远写在凡人之上了。主要是这就会有一个问题，我一直很在意这种问题，尤其在花女王里面特别生气地写过，你这样战斗平衡很容易就做得稀巴烂，因为强度完全就是剧本娘一支笔……为了让几个十几岁的凡人小孩能够参与神明的战斗，特意给他们每个人分配了一个没有脸的神作为庇护，……事实上也确实是做得稀巴烂就是了。</p><p>还有让人火大的ナギサ，摘了尸鬼耳朵做实验。不行真的会有点恶心到我，我当时对着尸鬼割自己耳朵的战斗画面咳咳咳狂吐，……ナギサ看起来蛮正常的一个小孩，怎么玩这么大……</p><p>以及茶褐色外套的哥们的谜之立场。救命，你怎么能做得到一会儿好人一会儿又能超狠心做坏人，刚刚还是要干死主角的样子，一会儿又觉得可以可以大家一起去干掉邪神吧。我能理解剧本娘的意思是间谍哥顾及到家族的安危，可是这写的变化也太过于莫名其妙，让我感觉这哥们完全没有自己的决心，……说起来，哥们你和小鬼还不是一代人呢，我看小鬼们就是看弟弟的感觉，可这哥们年纪比我还大啊（x），感觉完全就是捉摸不定又不太懂事的状态……</p><p>不过嘉隆老师是真的顶。（双手合十）愿主能够原谅你们的罪孽。</p>]]></content>
    
    
    <summary type="html">tbc</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Flos" scheme="https://aleryxiao.github.io/categories/Tavg/Flos/"/>
    
    
  </entry>
  
  <entry>
    <title>逢魔が刻 ～かくりよの縁～</title>
    <link href="https://aleryxiao.github.io/Tavg/Sakura/2655f8cd.html"/>
    <id>https://aleryxiao.github.io/Tavg/Sakura/2655f8cd.html</id>
    <published>2022-12-20T14:38:12.000Z</published>
    <updated>2023-01-02T14:01:45.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><ul><li><p>简评：[误]入幽世的少女冒险记</p></li><li><p>标签：和风奇幻</p></li><li><p>推荐：3-&#x2F;5</p></li><li><p>篇幅：中篇（25h）</p></li><li><p>Points</p><ul><li>5*个人线（真相线为&#x3D;&#x3D;常磐线&#x3D;&#x3D;，但不锁线）</li><li>攻略难度低，可以调整数值跳转</li><li>糖分不是很高，有部分场景戳到的话会觉得很甜（我就有好几个&gt;w&lt;），但是总体上感情发展方面的描写只能说是一般（其实我觉得明明可以写得很好！！很生气，好牌乱打）</li><li>关于日系神话的设定引入比较多，这些相关的文本也比较难…（但是我都嘎嘎跳，甚至连游戏内词典都没翻x（它怎么不能一键调用啊？）好像也没影响整体理解）</li><li>真相不是很复杂，故事也简单，如果按おすすめ顺序玩下来会觉得信息量比较低</li><li>所以总的来说就是不是很甜，故事能圆上但是不算很刺激，也没什么激动人心的波折，但是要说很不好的地方也说不出来，就是普普通通吧</li><li>画的真的是好看啊！！！！！！！！</li></ul></li><li><p>（如果你不在意剧透一些可能小雷的地方，可以去看一看剧透篇的1，剧透程度大概截止到按顺序攻略的一半位置（虽然是这么说，不过前一半根本就没有什么主线信息量就是了2333）</p></li></ul><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><h3 id="1-说在前面的一些（关于女主的一些）"><a href="#1-说在前面的一些（关于女主的一些）" class="headerlink" title="1. 说在前面的一些（关于女主的一些）"></a>1. 说在前面的一些（关于女主的一些）</h3><p>（无关）玩了二十个小时我都还不知道水绪怎么念（）我还是喜欢男主喊喊名字的qwq，不过声优们在不读名字的地方很多也做了小发挥，喜欢（现在知道了，念ミオ，音同澪，好好听啊~）</p><p>女主是神籬（ヒモロギ），查了一下百度感觉不是游戏里的意思，根据游戏里的意思，是类似神明的供品一样的存在。神籬被设定拥有与一切有灵之物有很高的亲和力，容易被万物所爱；生来的意义就是为了“神のものになる”，字面意义上的：成为神的所有物，能够非常非常大的程度上提升神明的力量。所有的意思呢是指：要么是被神明连灵魂都吃掉，要么是永远寸步不离地陪伴在神明的身边，……即使是不用痛苦地死掉，这个陪伴也没有那么轻松，是需要一个仪式的，如果神明不够强大的话神籬就会失去一切感知、失去“自我”。</p><p>女主掉进幽世然后被狐神培养的过程，就是不断作为神籬觉醒的过程，在觉醒之后她的气息会完全被神们知道（和风神话设定下有非常多的神），按游戏里的说法，会被当做肉一样去争抢，女主的意识根本不重要……（。）</p><p>怎么说，不是说这个背景不行，但是这种设定好人神供奉一样的背景然后玩家站在一个被供奉的贡物的视角就很不爽，你这也不是个抖M游戏（参见怀有特殊的血液的小仓唯in大菠萝），就是个平凡的少女童话啊，……女主怎么跟“牺牲玉帛,弗敢加也”里的牺牲（。）在神眼里是一个待遇啊！！</p><p>而且，虽然奥，作为供品的女主不是什么力量都没有，说了有亲和力，然后也会有一些预知力，她的祈祷也会有愿力，（其实我觉得贡物有特殊力量的设定就有点怪怪的2333），但是这些都不是能打的力量而已，而且也不受控，基本看剧本娘心情出现，整篇游戏的立场就是被保护被保护被保护……与此同时，水绪是经典的温柔善良又有责任感类型的日乙女主，不免有些时候就看起来有点来火了……&amp;……是不是圣母我不好说吧，总之没有体现出不圣母的地方……</p><h3 id="2-各角色线路吐槽"><a href="#2-各角色线路吐槽" class="headerlink" title="2. 各角色线路吐槽"></a>2. 各角色线路吐槽</h3><p>a. 奏太</p><p>怎么说呢，阳光开朗积极向上超受欢迎的二次元美少年虽然不算我xp但是也是可以的！但是写得……啊啊啊啊有点绷不住</p><p>最早打得一条线了现在有点模糊，记得最清楚的就是女主和奏太第二次遇到死魔事件，也就是大静谧（博主你什么取名方法），然后两个人一路逃到[病葉床]（玩完了我都不知道这个词是什么意思2333）的一个阴暗的摆了一张沙发的灰扑扑房间开始对线。奏太挺人类的挺正常的，他的能力能救女主本来就挺了不起了，能保护好女主就很值得开心了，女主“不行，我们得出去救大家”大概就是这种很无聊的对话进行了非常久……</p><p>考虑到女主和奏太是镇守学舍的学生，打比方的话可以说是现世的警校生之类的存在，对他人有保护的责任之类的想法的产生也没什么值得质疑的，但是，也不是说女主很圣母或者是我的话我就不劝他救人，怎么说呢……我觉得很无谋啊……而且，女主她也不能打架啊！！！虽然反复强调女主是有“能力”的，但是基本上也就是什么“看穿弱点”啊“祈祷”啊之类的辅助能力，在这节点他们已经直面过死魔了，女主对自己的战斗力应该完全有数……</p><p>所以女主干的事情其实是：啊？你害怕死掉？你觉得做不到？そんなじゃだめよ…为了保护大家！頑張らなきゃ！！！……对于我的核心雷点是，女主她自己打不了，奏太不是很想打，但是女主正在几乎是逼迫地希望奏太去打一场赢的概率几乎为0的仗……</p><p>总之这段超级长，打得我直接下头了，之后半个月都没碰游戏机……SOS</p><p>b. 宵宫<br>呜呜、せんせい我的せんせい——刀的名字是五月雨也好好听呀！！同样是不太戳我xp的优雅成男，快速掠过（？）这里我也简略吧。剧情矛盾也很简单，都在皓身上，皓是女主的愿望所形成的神在月白线里月白的调侃里提到一句以外再也没有照应过2333，女主作为召唤师存在的可能性也完全是看剧本娘的心情嘛（）（皓这么强哎。女主多来几次可以组一个军队吧……（？））</p><p>比较难受的是月白拜托女主回现世神社的剧情，确实那里并不安全，女主犹豫是合理的，可是宵宫去了就会死掉的设定也是真的、是宵宫自己也知道的，女主说个两句宵宫就很主动地说要去要去就很奇怪，你要是真的喜欢她应该是想长久地守护她而不是瞒着她保护她一次、然后让她的余生一直背负着负罪感，而且能去的也不是非宵宫不可，想不到让五月雨去也总有别的办法啊……宵宫这么想为了女主自我牺牲是我想不明白的……还是说就是为了多凑一个分支结局啊……</p><p>c. 颯</p><p>在这个游戏我的初恋啊！！！女主逢魔之刻跑进幽世的时候，刚刚摆脱危机来到平静的地方，看到的就是颯在无人的花海里安静地坐着。颯多好看啊，不只是立绘里，剧本娘也不止一次的描写这个木魂、地主神的美丽的外貌了嘿嘿x</p><p>而且是细谷！！！众所周知（也没有）我的命中注定的老公我早已遇见，就是终远的顶流烫男人西恩·布洛菲瓦兹&#x3D;w&#x3D;就是细谷桑配的~啊，但是这也导致了一个问题，我对细谷的声音的印象直接定格了，就是那种，嗯嗯，总是觉得这个声音对应的就是那种学识渊博的、成熟稳重还有点屑的成男……同样的问题也影响到我玩黑蝶的体验了（）但是黑蝶还好，至少对方也是个看起来成熟靠谱的少年。可是，ハヤテ给人的感觉就完全不一样……不一样的地方正是我超中意他的地方qwq</p><p>这次是一个一直以来对于幽世颇有“漂浮感”的天生神明~只有花花草草大自然能够听见他的声音，他和幽世的妖魔鬼怪神明没法交流，也没有很强的共情，对镇守学舍的工作没有什么激情也没有什么归属感（不如说他为什么会去那里这点就很奇怪……）但是水绪给了他传达声音的机会，让他对镇守学舍的大家、尤其水绪产生了羁绊和情感……还挺美好的呀，哈哈哈（）</p><p>颯是个很天然的带着孩子气的神，对女主有非常天然的保护欲占有欲，非常可爱（）开头我就被他在女主宿舍门口等女主一起去上学结果发现女主已经去了然后在那里沮丧萌到了&gt;w&lt;一起编花环也很温柔很美好，和花说话也超级喜欢。</p><p>有七个章节不只是因为涉及主线多，还有因为颯自损修为（？）劈了自己本源的大树把女主送回现实然后两个人互相痛苦思念数日女主又自己跑回来，颯惊讶但是又不是很生气因为他发现没有水绪的自己真的太痛苦了，两个人贴贴了一阵就开始准备仪式，中间写了一大堆伙伴们帮忙准备东西的剧情（）。好吧，我是真的觉得女主这一个来回有点莫名其妙的，试错成本也太高了吧，……完全是没有必要的事情……而且颯也完全不跟女主商量就做决定，嗨呀）……</p><p>对了下雨那段！我超级喜欢啊啊啊啊 TvT 有种孩子长大了的欣慰感（）</p><p>（而且，暗示了半天，柏木前辈到底和颯是什么联系啊2333 写明白一点嘛）</p><p>d. 月白</p><p>太好了我觉得这条线写的烂爆了！（侧目）不如说我真的很讨厌这个人设出现在攻略对象里！女主完全一副被强者设计和引诱的样子啊……（声优的语气也屑得很贴脸很符合角色2333）</p><p>(1) 关于喜欢</p><blockquote><p>女主：（我好像喜欢月白桑呢，明明并不是很了解，喜欢的是什么呢）<br>女主：（是的，作为神的他也好，作为“月白”的他也好，我喜欢他的全部）<br>月白：你喜欢我啊。我也喜欢你哦。（不过是作为神籬的那种啦，你能成为我的东西吗）</p></blockquote><p>所以月白在不是神的时候是什么样子啊？连一段插叙都吝啬吗（）剧情里根本没法认识到月白不像个神的样子啊……</p><p>(2) 关于开心</p><blockquote><p>女主：和月白待在一起很开心！（因为喜欢月白桑所以只要看见就会觉得开心）<br>月白：和水绪待在一起很开心！（看神籬少女为了她的单纯到愚蠢的愿望努力、难过，觉得非常有趣）</p></blockquote><p>(3) 关于愿望</p><blockquote><p>女主：我希望大家能一起平安幸福地生活下去，希望你解决幽世的困境<br>月白：好啊，那么我们就干脆斩草除根，把可能变坏的存在都清剿干净吧<br>月白：你看啊，他们都是因为你的愿望死掉的哦，我做得是不是很棒？<br>女主：……<br>月白：你哭什么呀，为什么不会觉得开心呢？（一边欣赏女主的悲伤的表情觉得有趣）<br>月白：与其放置他们不管，不如完全从根源上杜绝他们犯罪的可能性嘛？</p></blockquote><p>可恶，我一点都不觉得这种屑很戳我，我觉得……恶心。神啊，那可是你的子民啊。。。你觉得那里治安差有人嗑药会出坏人，那你自己不管怎么也不让镇守学舍管呢……</p><p>多说一句，我觉得你们幽世还是应该要有幽世法的，你们的神实在太乱来了……而且说着想要稳定的幽世所以建立了镇守学舍管理，可是管理到什么程度也不设定，全看学生和老师的良心……这怎么运行得下去啊（）</p><p>(4) 关于喜欢_2</p><blockquote><p>女主：我喜欢你，即使成为你的神籬也心甘情愿那种<br>月白：（掏出一个不能说谎的幻境，让幻境里每一个女主熟悉的人都出来动摇一下女主的喜欢的想法，用以考验女主）</p></blockquote><p>这里是我最无语的地方，也是BE分叉。如果女主但凡有一点动摇，或者之前好感没刷好，就会被月白直接在仪式里送走，变成没有自我意识的神籬……如果女主一路坚定地重复爱语，月白就会在让她成为有自我意识的神籬然后娶她。……好吧，反正都是变成你的东西啦。可恶，我下意识地很讨厌一些“无法退路的情境”。</p><p>总的来说，就是这个人神恋真的写的很不舒服，男主一直是以神看供品的视角玩弄女主的心情并为此感到快乐，嘴上说着喜欢到底是什么样的喜欢，总之我觉得是无法和女主的情感同等比较的喜欢，就算他的BestEnd是全游戏唯一一个上车的也一样，我只能共情到女主的恼怒和无力，并没有ドキドキ。剧本娘的狐神很有神的对于人的疏离感、上位感，唯独缺乏恋爱感。</p><p>e. 常盤</p><p>剧本娘你要不要看看自己在男女主终于能互诉衷肠之前都写的是啥？？？啊？？？有些片段你写的是ok，但是基本的に完全是莫名其妙……</p><p>一见钟情我完全可以接受，好吧，男主不是很爱说话天天对她摆脸色说重话女主每次都“なんとなく”地过去没话找话，也行吧，忍忍，毕竟明里暗里还是说男主挺关心女主的，和神無一起买衣服走失被男主捡回来挨训那次男主误会女主不高兴了拼命解释也挺可爱的，milkHall的甜点和戏份超甜我也喜欢（虽然我真的能感觉到女主在每次对话里的尴尬的感觉……），但是但是，啊啊啊啊我最不能忍的是，那个重要的告白写的是啥啊？？？</p><blockquote><p>女主：*表白*<br>男主：你是不是误会了什么，我不喜欢你。<br>女主：就算这样我也喜欢你，想要帮助你实现目的。<br>男主：*强吻<em>（我草，甚至是深吻，女主都傻了）<br>女主：？？？どうして<br>男主：你想要的就是这种东西对吧！反正我不喜欢你。速速滚吧！<br>女主：？？？*泪如雨下</em><br>（女主走了以后）<br>男主：我怎么能这样呢！</p></blockquote><p>我理解剧本娘觉得男主冲动又傲娇的样子有萌点，但是这个冲突是否有点过于强行了……我好无语，我真的好无语，为什么把男主写的像个冲动傻逼，啊？？？我觉得剧本娘的意思是，常盘一直喜欢水绪一直为她默默地付出没想过要被喜欢，也不希望她的恋心影响到自己保护她的大业，所以惊讶不相信觉得是误会、所以拒绝；发现女主真的喜欢他，又非常感动，因为自己其实非常喜欢现在的她，所以激动地强吻（？）；吻完发现自己打乱了自己的规划，对自己做的事情也非常惊慌失措，所以也惊慌失措地说出伤人的话来赶走女主。</p><p>草，我简直就是剧本娘的知心妹妹，把它解释通了，可是你看这个剧情从玩家和女主视角来看是个啥啊！！是个啥啊！！！？？？而且最重要的是，男主一直以来不都是在坚持着他保护女主这件事情作为他生存的意义吗，更何况他对现在的女主也是隐约存在恋心的呀，怎么能做得到这么伤害女主的事情，拜托这不是不懂女孩子的问题，是他吗根本就没有照顾女主心情的主观想法……别的剧情有的时候男主确实说话难听不爱想，可是他关心的意思都完全传达给女主了呀，那这里传达了的是什么啊？？？常盘，被剧本娘绑架了你就眨眨眼（）</p><p>好啦，跳过这一段我还是非常喜欢常盘的，谁会讨厌喜欢甜食、说到甜食会kirakira的容易脸红的纯情少年啊<del>虽然冲动傲娇说话难听不爱想，但是其实有非常温柔的心啊</del>（麻烦给我来一份常盘Special~~）</p><p>以及，怎么说呢，我觉得常盘的想法很真实，比如说：既然花了半个魂魄才保护了你，也想一直保护下去；既然至今为止的人生都在保护你，那么我也不会后悔，不会否定我的努力；之前这份感情说不上是喜欢，（或者说只是一种执念，）但是现在的我真的很喜欢现在的你，看到你现在好好的我好开心。</p><p>确实，我想了一下我如果第一次做了这个选择，可能也会后面一直这么做（特别喜欢的对象的话），如果后悔了就什么都没有了，有种像玩游戏一直氪金氪了很多后来弃坑也不愿意卖掉，因为一旦卖掉好像那些充进去的钱、看起来“亏损”的钱就变成实际的东西了……（好像也不是很恰当2333）玩游戏氪金也不会说后悔氪金，不管怎么样都会哄自己说：因为喜欢才氪的，因为开心，不会后悔的。</p><p>但是这样的感情……也太沉重了吧。即使水绪喜欢上了常盘，水绪的喜欢也无法回应这份感情，就算水绪不提，她心里也一定抱有很重的亏欠的感觉，这样的恋情……嗯……或者说，这种事情只要是知道了，总会抱有亏欠和罪恶的感觉，无论对方怎么想的都会觉得很难受吧……</p><p>（Soma配得也太好了，啊啊啊啊啊啊啊啊啊啊啊）（虽然一开始觉得他配脸这么成熟的角色有点怪，但是啊啊啊啊啊啊啊啊啊啊太会配了）</p><h3 id="3-总评"><a href="#3-总评" class="headerlink" title="3. 总评"></a>3. 总评</h3><p>发现我个人线写的全是槽点（草），但是其实玩的过程也没有那么生气，只是说它让我生气的地方让我印象很深刻……而且也有很多甜的地方）（x）但是也不够突出，不是那种再过好几个月我都能记得好多的故事和人设。……</p><p>不过画的是真的好好看啊……！！！！</p><p>嗯……情绪发泄完了居然有5k字了，我好累啊……就写到这里吧……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无剧透篇&quot;&gt;&lt;a href=&quot;#无剧透篇&quot; class=&quot;headerlink&quot; title=&quot;无剧透篇&quot;&gt;&lt;/a&gt;无剧透篇&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简评：[误]入幽世的少女冒险记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签：和风奇幻&lt;/p&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Sakura" scheme="https://aleryxiao.github.io/categories/Tavg/Sakura/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编语言 速效救心丸</title>
    <link href="https://aleryxiao.github.io/Coding/74e40bab.html"/>
    <id>https://aleryxiao.github.io/Coding/74e40bab.html</id>
    <published>2022-12-07T07:03:08.000Z</published>
    <updated>2023-01-02T14:07:00.666Z</updated>
    
    <content type="html"><![CDATA[<p>帮助快速上手汇编语言编程，虽然只限于编程<br>配套Bilibili视频：<a href="https://www.bilibili.com/video/BV1BM411B7ZB/">上篇</a>；<a href="https://www.bilibili.com/video/BV1BM411B7ZB/">下篇</a></p><h1 id="VScode配置调试环境"><a href="#VScode配置调试环境" class="headerlink" title="VScode配置调试环境"></a>VScode配置调试环境</h1><ol><li>安装插件TASM&#x2F;MASM</li><li>右键扩展设置，选择Assembler：MASM</li><li>右键调试即可开始调试了！</li></ol><h1 id="Debug-exe"><a href="#Debug-exe" class="headerlink" title="Debug.exe"></a>Debug.exe</h1><blockquote><p>R命令：查看、改变CPU寄存器的内容<br>D命令：查看内存中的内容<br>T命令：执行一条机器指令<br>G命令：从停顿的地方运行到底</p></blockquote><h1 id="第一段代码：Hello-World"><a href="#第一段代码：Hello-World" class="headerlink" title="第一段代码：Hello World"></a>第一段代码：Hello World</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DSEG SEGMENT</span><br><span class="line">        MESS DB &#x27;Hello, World!&#x27;,0DH,0AH,24H</span><br><span class="line">DSEG ENDS</span><br><span class="line"></span><br><span class="line">SSEG SEGMENT PARA STACK</span><br><span class="line">             DW 256 DUP(?)</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">              ASSUME CS:CSEG, DS:DSEG</span><br><span class="line">        BEGIN:MOV    AX,DSEG</span><br><span class="line">              MOV    DS,AX</span><br><span class="line">              MOV    DX,OFFSET MESS</span><br><span class="line">              </span><br><span class="line">              MOV    AH,9</span><br><span class="line">              INT    21H</span><br><span class="line">              </span><br><span class="line">              MOV    AH,4CH</span><br><span class="line">              INT    21H</span><br><span class="line">CSEG ENDS</span><br><span class="line">END BEGIN</span><br></pre></td></tr></table></figure><h1 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h1><p>用以下指令可以写一个基础的程序：</p><ol><li>段定义+Assume</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XXX SEGMENT(XXX:DATA/STACK/CODE)</span><br><span class="line">XXX ENDS</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CSEG, DS:DSEG, SS:SSEG</span><br><span class="line">MOV AX,DSEG</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOV AX,SSEG</span><br><span class="line">MOV SS,AX</span><br></pre></td></tr></table></figure><ol start="2"><li>数据定义</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(ORG 1000)</span><br><span class="line">(NAME) DB ?/...</span><br><span class="line">(NAME) DB N DUP(?/...)</span><br><span class="line">db:12H/dw:1234H</span><br></pre></td></tr></table></figure><ol start="3"><li>MOV</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,Y</span><br><span class="line">MOV Y,AX</span><br><span class="line">MOV AX,BX</span><br></pre></td></tr></table></figure><ol start="4"><li>+-</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD AX,X;AX+=X</span><br><span class="line">SUB AX,X;</span><br><span class="line">INC AX;AX++</span><br><span class="line">DEC AX;AX--</span><br><span class="line"></span><br><span class="line">NEG AX ;取负</span><br></pre></td></tr></table></figure><ol start="5"><li>程序的终止</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH,4CH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>稍后会讲的进阶指令：</p><ol><li>Label和JUMP：跳转</li><li>分支和循环</li><li>堆栈的使用</li><li>&lt;函数&gt;：PROC和MACRO</li><li>INT 21H指令：输入&#x2F;输出</li></ol><h1 id="寄存器的使用"><a href="#寄存器的使用" class="headerlink" title="寄存器的使用"></a>寄存器的使用</h1><p>在汇编语言中，我们不能对内存中的数据进行直接操作，如果要操作，需要把数据先<code>MOV</code>到寄存器中再进行处理。<br>为了写代码的过程更顺滑，最好先简单了解一下这些寄存器的使用，当然，你也可以只了解通用寄存器的使用，别的等用到了再去查询。<br>我会尽可能简单地表述。</p><p>8086 CPU 中有14个16位寄存器 。16位的存储可以用16进制表示，BeLike：<code>123AH</code>（H表示16进制)在查看内存情况的时候，由于数据从高位到低位存储，BeLike：<code>3A 12</code></p><p><img src="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">  </p><h3 id="通用寄存器：AX，BX，CX，DX"><a href="#通用寄存器：AX，BX，CX，DX" class="headerlink" title="通用寄存器：AX，BX，CX，DX"></a>通用寄存器：AX，BX，CX，DX</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DSEG ...</span><br><span class="line">X DB 12H</span><br><span class="line">Y DB ?</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">CSEG...</span><br><span class="line">...</span><br><span class="line">MOV AH,X</span><br><span class="line">MOV Y,AH ;Y--12H</span><br></pre></td></tr></table></figure><p>可以拆分为两个寄存器使用（AH和AL），不过各自有各自的独特作用，用到再提，这和它们的名字是关联的</p><p>说到底为什么&lt;通用&gt;寄存器会有&lt;独特的作用&gt;？<br>这是因为&#x3D;&#x3D;一些内置的指令依靠<strong>固定</strong>的寄存器传递参数&#x3D;&#x3D;，所以这些寄存器也有了独特的作用</p><p>一般来说随便用就可以，反正里面的东西不久存，只是用来做&#x3D;&#x3D;中转&#x3D;&#x3D;</p><h5 id="AX：Accumlator-累加器"><a href="#AX：Accumlator-累加器" class="headerlink" title="AX：Accumlator 累加器"></a>AX：Accumlator 累加器</h5><p>特殊功能和MUL&#x2F;DIV有关，后面再说</p><h5 id="BX：Base-基地址寄存器"><a href="#BX：Base-基地址寄存器" class="headerlink" title="BX：Base 基地址寄存器"></a>BX：Base 基地址寄存器</h5><p>可以存储地址并访问<br>说到地址，就得提一下汇编语言里地址的表示方法<br>在汇编语言里，内存中的地址BeLike：<code>204B:1001</code> （以16进制表示）<br><code>204B</code>是<strong>段地址</strong>，<code>1001</code>是<strong>偏移地址</strong>，各需要一个Word进行存储<br>有两个指令对应的获取内存单元的这两种地址<br>    <code>SEG</code>可以获取<strong>段地址</strong>（这个段就是指我们程序对应的段Segment），<code>OFFSET</code>可以获取<strong>偏移地址</strong><br>    使用这两个词只需要在MOV时加在变量前即可，比如<code>MOV BX offset X</code><br>在“通过地址找内容”这件事方面，一般用BX存储偏移地址<br>比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X DW 1234H</span><br><span class="line">Y DW ?</span><br><span class="line">...</span><br><span class="line">MOV BX, OFFSET X;BX中存储了X的偏移地址</span><br><span class="line">MOV Y, [BX];BX存储的偏移地址对应的内容被存放到y</span><br></pre></td></tr></table></figure><p>一般来说，<code>[BX]</code>就是指 <code>DS:[BX]</code>，默认段地址为数据段，当然你也可以指定为CS和SS</p><h5 id="CX：Count-计数器"><a href="#CX：Count-计数器" class="headerlink" title="CX：Count 计数器"></a>CX：Count 计数器</h5><p>和循环指令<code>LOOP</code>有关</p><p>LOOP指令类似于C语言中的For循环，<code>loop NAME</code>近似于<code>for(cx;;cx--)</code><br>关于LOOP的用法，具体到程序结构再说好了~。</p><h5 id="DX：Data-数据寄存器"><a href="#DX：Data-数据寄存器" class="headerlink" title="DX：Data 数据寄存器"></a>DX：Data 数据寄存器</h5><p>特殊功能和MUL&#x2F;DIV有关，后面再说<br>也有与输入输出的暂存有关的功能（9.10号指令）</p><h3 id="指针变址寄存器：SP，BP，SI，DI"><a href="#指针变址寄存器：SP，BP，SI，DI" class="headerlink" title="指针变址寄存器：SP，BP，SI，DI"></a>指针变址寄存器：SP，BP，SI，DI</h3><p>都倾向于用来存地址</p><h5 id="SP：Stack-Pointer"><a href="#SP：Stack-Pointer" class="headerlink" title="SP：Stack Pointer"></a>SP：Stack Pointer</h5><p>和堆栈段的使用有关，定义堆栈段要记得手动把SP放在栈顶</p><h5 id="BP：Base-Pointer"><a href="#BP：Base-Pointer" class="headerlink" title="BP：Base Pointer"></a>BP：Base Pointer</h5><p>和BX有类似的用法，只是一般更倾向于用在堆栈的数据里，<code>[BP]</code>默认为<code>SS:[BP]</code></p><h5 id="SI：Source-Index"><a href="#SI：Source-Index" class="headerlink" title="SI：Source Index"></a>SI：Source Index</h5><h5 id="DI：Destination-Index"><a href="#DI：Destination-Index" class="headerlink" title="DI：Destination Index"></a>DI：Destination Index</h5><p>和BX有类似的用法，<code>[SI]</code>默认为<code>DS:[SI]</code><br>如果要转移数据，倾向于用SI存原地址，DI存新地址</p><h3 id="段寄存器：CS，DS，SS，ES，IP"><a href="#段寄存器：CS，DS，SS，ES，IP" class="headerlink" title="段寄存器：CS，DS，SS，ES，IP"></a>段寄存器：CS，DS，SS，ES，IP</h3><p>段的存在方便我们以&#x3D;&#x3D;段地址+偏移地址&#x3D;&#x3D;的方式定位内存单元<br>刚刚在例子中看到，一般的程序我们定义三个段，Data、Stack和Code，它们的作用和名字是一致的</p><p>这些寄存器都和程序段还有程序的运行有关。<br>在程序启动的时候，操作系统会把IP（Instruction Pointer）指向程序的第一句开始运行，之后IP会一直指向每次要运行的下一条指令（显然我们可以用IP玩一些花活，但是对于简单的程序，我们没有必要操作IP）</p><p>在代码段的开始，我们就用Assume语句声明CS、DS、SS的地址<br>和CS不同，DS和SS寄存器的值需要我们手动指定，而与SS寄存器绑定的SP指针也需要我们手动设置（SS:SP指向的就是栈顶元素）</p><p>ES是Extra Segment，程序有附加段落的时候才用，用法和DS SS差不多</p><h3 id="标志寄存器-FLAG"><a href="#标志寄存器-FLAG" class="headerlink" title="标志寄存器 FLAG"></a>标志寄存器 FLAG</h3><p>只是写代码的话不用管它<br>16位分开使用，有各自不同的意思，结果会以下面的形式呈现在-R中</p><p><img src="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70"></p><h1 id="阶段练习"><a href="#阶段练习" class="headerlink" title="阶段练习"></a>阶段练习</h1><p>有以上的知识已经能写很多代码。</p><h4 id="练习a-x-y"><a href="#练习a-x-y" class="headerlink" title="练习a: x+y"></a>练习a: x+y</h4><blockquote><ol><li>在数据段（data segment）中定义3个word，其中x&#x3D;1234H，y&#x3D;2345H, z&#x3D;?</li><li>将x+y的结果保存在z中</li></ol></blockquote><h1 id="进阶指令"><a href="#进阶指令" class="headerlink" title="进阶指令"></a>进阶指令</h1><p>这里开始会有一点复杂，建议一边写一边看</p><h3 id="1-Label和Jump：跳转"><a href="#1-Label和Jump：跳转" class="headerlink" title="1. Label和Jump：跳转"></a>1. Label和Jump：跳转</h3><p>一段代码可以拥有label，Jump NAME 即可跳转至label位置<br>比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN：MOV X,AX</span><br><span class="line">JUMP DONE</span><br><span class="line">MOV AX,Y</span><br><span class="line">...</span><br><span class="line">DONE:</span><br><span class="line">MOV AH, 4CH</span><br><span class="line">INT 21</span><br></pre></td></tr></table></figure><p>在这段程序中，<code>MOV AX,Y</code>就会直接被跳过</p><h3 id="2-分支和循环"><a href="#2-分支和循环" class="headerlink" title="2. 分支和循环"></a>2. 分支和循环</h3><h4 id="分支-CMP-JGE-x2F-…"><a href="#分支-CMP-JGE-x2F-…" class="headerlink" title="分支 CMP-JGE&#x2F;…"></a>分支 CMP-JGE&#x2F;…</h4><p><img src="/../../../assets/Pasted%20image%2020221206112205.png"></p><p>BeLike:(求abs(AX)保存在AX中)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">...</span><br><span class="line">CMP AX,0</span><br><span class="line">JGE DONE; Jump if Greater or Equal</span><br><span class="line">NEG AX</span><br><span class="line">DONE:</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h5 id="练习b-求最大值"><a href="#练习b-求最大值" class="headerlink" title="练习b: 求最大值"></a>练习b: 求最大值</h5><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x&#x3D;1234H，y&#x3D;2345H, z&#x3D;-1234H，w&#x3D;?</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="循环-LOOP"><a href="#循环-LOOP" class="headerlink" title="循环  LOOP"></a>循环  LOOP</h4><p>一种简单的循环，类似于<code>for(cx;;cx--)</code>。（事实上，你可以用JUMP和分支结构来实现循环）</p><p>LOOP NM过程中：<br>    0. CMP CX,0<br>    1. 如果CX&gt;0，继续执行以下语句，否则跳出<br>    2. DEC CX(CX&gt;0)<br>    3. JUMP NM</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV CX,6</span><br><span class="line">NM: ...</span><br><span class="line">LOOP NM;这样写一共执行CX次（声明NM时执行1次，LOOP中执行CX-1次）</span><br></pre></td></tr></table></figure><h5 id="练习c-数组初始化"><a href="#练习c-数组初始化" class="headerlink" title="练习c: 数组初始化"></a>练习c: 数组初始化</h5><blockquote><p>在数据段（data segment）中分配100字节，并为每个字节依次赋值0-99。</p></blockquote><h3 id="3-堆栈的使用"><a href="#3-堆栈的使用" class="headerlink" title="3. 堆栈的使用"></a>3. 堆栈的使用</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>两个好用的方法</p><h5 id="比较直观的（堆栈段中做定义）"><a href="#比较直观的（堆栈段中做定义）" class="headerlink" title="比较直观的（堆栈段中做定义）"></a>比较直观的（堆栈段中做定义）</h5><ol><li>在堆栈段划分位置，保存栈顶位置</li><li>在程序段开始的时候把堆栈段的位置告诉堆栈寄存器SS，把栈顶的位置告诉指针寄存器SP</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">      STACK DW  128 dup(?)</span><br><span class="line">      TOP   DW LENGTH STACK ;划定范围</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">           ASSUME CS:CSEG,DS:DSEG,SS:SSEG</span><br><span class="line">      MAIN:</span><br><span class="line">           MOV    AX,DSEG</span><br><span class="line">           MOV    DS,AX</span><br><span class="line">           MOV    AX,SSEG</span><br><span class="line">           MOV    SS,AX</span><br><span class="line">           MOV    AX,TOP</span><br><span class="line">           MOV    SP,AX                        ;栈顶地址载入</span><br></pre></td></tr></table></figure><h5 id="稍微没那么直观的（程序段中划空间）"><a href="#稍微没那么直观的（程序段中划空间）" class="headerlink" title="稍微没那么直观的（程序段中划空间）"></a>稍微没那么直观的（程序段中划空间）</h5><p>直接给SP赋值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">SSEG ENDS</span><br><span class="line">;ss:0000-ss:1000</span><br><span class="line">CSEG SEGMENT</span><br><span class="line">            ASSUME CS:CSEG, DS:DSEG,SS:SSEG</span><br><span class="line">      BEGIN:MOV    AX,DSEG</span><br><span class="line">            MOV    DS,AX</span><br><span class="line">            MOV    AX,SSEG</span><br><span class="line">            MOV    SS,AX</span><br><span class="line">            MOV    SP,1000H                      ;手动规定了1000H的空置空间(OFFSET 0H-1000H)</span><br></pre></td></tr></table></figure><h4 id="PUSH和POP"><a href="#PUSH和POP" class="headerlink" title="PUSH和POP"></a>PUSH和POP</h4><p>注意：&#x3D;&#x3D;只能操作寄存器&#x3D;&#x3D;，不能直接操作内存单元<br><code>PUSH AX</code>：将AX的值入栈（如果AX两个字节，就会入栈两个字节，SP也相应-2）<br><code>POP AX</code>：出栈，内容保存在AX（如果AX两个字节，就会入栈两个字节，SP也相应+2）</p><h4 id="用SP和BP操作堆栈"><a href="#用SP和BP操作堆栈" class="headerlink" title="用SP和BP操作堆栈"></a>用SP和BP操作堆栈</h4><p>在主程序只是暂存数据用的话，一般&#x3D;&#x3D;不用&#x3D;&#x3D;操作指针<br>但是，由于PROC需要使用到堆栈段，所以这是操作指针就是必要的，接下来在PROC中解释</p><h3 id="4-lt-函数-gt-：PROC和MACRO"><a href="#4-lt-函数-gt-：PROC和MACRO" class="headerlink" title="4. &lt;函数&gt;：PROC和MACRO"></a>4. &lt;函数&gt;：PROC和MACRO</h3><h4 id="PROC-amp-CALL（子程序结构）"><a href="#PROC-amp-CALL（子程序结构）" class="headerlink" title="PROC&amp;CALL（子程序结构）"></a>PROC&amp;CALL（子程序结构）</h4><h5 id="定义-PROC-RET-ENDP"><a href="#定义-PROC-RET-ENDP" class="headerlink" title="定义 PROC-RET-ENDP"></a>定义 PROC-RET-ENDP</h5><p>(Near 属性是默认值)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">CALL NM</span><br><span class="line"></span><br><span class="line">NM PROC</span><br><span class="line">...</span><br><span class="line">RET</span><br><span class="line">NM ENDP</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><p>完整的表达式：<br>调用：<code>CALL FAR/NEAR PTR NM</code><br>定义：<code>NM PROC FAR/NEAR</code></p><h5 id="子程序属性和调用"><a href="#子程序属性和调用" class="headerlink" title="子程序属性和调用"></a>子程序属性和调用</h5><h6 id="段内调用"><a href="#段内调用" class="headerlink" title="段内调用"></a>段内调用</h6><p>只需要Main（主Label调用）的话空置即可（默认Near）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:...</span><br><span class="line">CALL B;调用B</span><br><span class="line"></span><br><span class="line">PROC B:...;默认为near属性子程序</span><br><span class="line">RET</span><br><span class="line">B ENDP</span><br><span class="line">...</span><br><span class="line">END A</span><br></pre></td></tr></table></figure><h6 id="段间调用"><a href="#段间调用" class="headerlink" title="段间调用"></a>段间调用</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROC A:CALL FAR PTR B</span><br><span class="line">RET</span><br><span class="line">ENDP</span><br><span class="line"></span><br><span class="line">PROC B FAR:...;写明属性</span><br><span class="line">RET ENDP</span><br></pre></td></tr></table></figure><h5 id="小心堆栈！"><a href="#小心堆栈！" class="headerlink" title="小心堆栈！"></a>小心堆栈！</h5><p>PROC的本质是：入栈程序出口指针，RET时从回到出口指针的位置<br>所以：</p><ol><li>第一个出栈元素会是一个偏移地址</li><li>如果最后SP的指针位置不对，就无法正确RET</li></ol><p>简单的方法：&#x3D;&#x3D;用寄存器BP保护SP&#x3D;&#x3D;，使用BP进行数据的读取</p><h6 id="例子a-1-x-y子程序化"><a href="#例子a-1-x-y子程序化" class="headerlink" title="例子a(1): x+y子程序化"></a>例子a(1): x+y子程序化</h6><blockquote><p>…</p><ol><li>在堆栈段push任意两个长度为1word的数据</li><li>使用子程序，将这两个数据的和存储于AX<br>…</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUM PROC ;取两个栈顶元素求和储存到AX中</span><br><span class="line">         MOV    BP,SP</span><br><span class="line">         MOV    AX,[BP+2]</span><br><span class="line">         ADD    AX,[BP+4]</span><br><span class="line">         RET</span><br><span class="line">SUM ENDP</span><br></pre></td></tr></table></figure><h6 id="练习b-1-求最大值-子程序化"><a href="#练习b-1-求最大值-子程序化" class="headerlink" title="练习b(1) 求最大值 子程序化"></a>练习b(1) 求最大值 子程序化</h6><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x&#x3D;1234H，y&#x3D;2345H, z&#x3D;-1234H，w&#x3D;?</li><li>在堆栈段push x,y,z</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="Macro（宏定义）"><a href="#Macro（宏定义）" class="headerlink" title="*Macro（宏定义）"></a>*Macro（宏定义）</h4><p>PROC的使用有调用开销（程序的中断 跳转 继续），而MACRO没有<br>MACRO相当于写代码的人把重复写代码的过程交给了汇编器，相比子程序来说，是通过多占程序的内存来提高运行速度（对机器来说，每调用一次Macro，就是把这段指令重复了一次）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NM MACRO R1,R2...(参数)</span><br><span class="line">...</span><br><span class="line">END M</span><br><span class="line"></span><br><span class="line">NM MACRO AX,BX...(寄存器取值)</span><br></pre></td></tr></table></figure><h3 id="5-INT-21H指令：输入-x2F-输出"><a href="#5-INT-21H指令：输入-x2F-输出" class="headerlink" title="5. INT 21H指令：输入&#x2F;输出"></a>5. INT 21H指令：输入&#x2F;输出</h3><p>其实查书就可以了</p><p>到这里汇编语言编程的&lt;大局&gt;已经描述完全</p><p>关于一些语句的细节可以通过搜索引擎和汇编相关的任何书籍进行确认~</p><h4 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h4><h5 id="1号指令：单个字符输入"><a href="#1号指令：单个字符输入" class="headerlink" title="1号指令：单个字符输入"></a>1号指令：单个字符输入</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH,1</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>(内容会保存在AL)</p><h5 id="10号指令：从键盘输入字符串"><a href="#10号指令：从键盘输入字符串" class="headerlink" title="10号指令：从键盘输入字符串"></a>10号指令：从键盘输入字符串</h5><p>内存里需要划分三个部分：<br>    1.一个字节存放最大长度（你写，溢出会被裁掉）<br>    2.一个字节存放实际长度（指令运行完CPU会写）<br>    3.一些字节用来存字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    MAXLENGTH    DB 100           ;一个字节，用它存最大的长度</span><br><span class="line">    ACTUALLENGTH DB ?             ;一个字节，用它存实际的长度，在指令执行后会被填写</span><br><span class="line">    STRING       DB 100 DUP(?)    ;用来存字符串</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">STACK SEGMENT</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">         ASSUME DS:DATA,SS:STACK,CS:CODE</span><br><span class="line">    MAIN:</span><br><span class="line">         MOV    AX,DATA</span><br><span class="line">         MOV    DS,AX</span><br><span class="line">         MOV    DX,OFFSET MAXLENGTH         ;把需要用到的内存块（三个部分）的地址存入DX</span><br><span class="line"></span><br><span class="line">         MOV    AH,10</span><br><span class="line">         INT    21H</span><br><span class="line"></span><br><span class="line">         MOV    AH,4CH</span><br><span class="line">         INT    21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h4 id="显示器输出"><a href="#显示器输出" class="headerlink" title="显示器输出"></a>显示器输出</h4><h5 id="2号调用：单个字符输出"><a href="#2号调用：单个字符输出" class="headerlink" title="2号调用：单个字符输出"></a>2号调用：单个字符输出</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DL,&#x27;A&#x27;</span><br><span class="line">MOV AH,2</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h5 id="9号调用：字符串输出"><a href="#9号调用：字符串输出" class="headerlink" title="9号调用：字符串输出"></a>9号调用：字符串输出</h5><p>你的字符串必须要以’$‘结尾！不然输出不会结束！（类似于’\0’，’$‘是一种字符串的终止符）<br>程序会将DS:DX地址开始输出字符到’$‘结尾</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,OFFSET STRING</span><br><span class="line">MOV AH,9</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><h4 id="练习d-大小写转换-输入输出"><a href="#练习d-大小写转换-输入输出" class="headerlink" title="练习d. 大小写转换+输入输出"></a>练习d. 大小写转换+输入输出</h4><blockquote><p>（分支&#x2F;循环&#x2F;子程序+输入输出）<br>用户输入一个单词，程序将所有大写转换为小写并输出到显示器<br>(注：’a’&#x3D;’A’+20H)</p></blockquote>]]></content>
    
    
    <summary type="html">帮助快速上手汇编语言编程的小教程</summary>
    
    
    
    <category term="Coding" scheme="https://aleryxiao.github.io/categories/Coding/"/>
    
    
    <category term="ASM" scheme="https://aleryxiao.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言 全家桶</title>
    <link href="https://aleryxiao.github.io/Coding/5b511fc.html"/>
    <id>https://aleryxiao.github.io/Coding/5b511fc.html</id>
    <published>2022-12-06T06:40:15.000Z</published>
    <updated>2023-01-02T14:07:00.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VScode配置调试环境"><a href="#VScode配置调试环境" class="headerlink" title="VScode配置调试环境"></a>VScode配置调试环境</h1><ol><li>安装插件TASM&#x2F;MASM</li><li>右键扩展设置</li><li>右键调试即可开始调试了！</li></ol><h1 id="debug-exe使用"><a href="#debug-exe使用" class="headerlink" title="debug.exe使用"></a>debug.exe使用</h1><p><a href="https://blog.csdn.net/weixin_38633659/article/details/125166093">https://blog.csdn.net/weixin_38633659/article/details/125166093</a></p><p>Debug是DOS、Windows都提供的实模式(8086方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。  </p><h2 id="1-Debug的常用功能"><a href="#1-Debug的常用功能" class="headerlink" title="1. Debug的常用功能"></a>1. Debug的常用功能</h2><blockquote><p>&#x3D;&#x3D;R命令：查看、改变CPU寄存器的内容；  &#x3D;&#x3D;<br>&#x3D;&#x3D;D命令：查看内存中的内容；  &#x3D;&#x3D;<br>E命令：改写内存中的内容：<br>U命令：将内存中的机器指令翻译成汇编指令：<br>&#x3D;&#x3D;T命令：执行一条机器指令；  &#x3D;&#x3D;<br>A命令：以汇编指令的格式在内存中写入一条机器指令。<br>Q命令：退出debug<br>P命令：类似于step over（“t”命令类似于step into），可用于跳过loop循环<br>&#x3D;&#x3D;G命令：跳过前面的代码，运行到指定的代码位置&#x3D;&#x3D;</p></blockquote><h2 id="2-R命令"><a href="#2-R命令" class="headerlink" title="2. -R命令"></a>2. -R命令</h2><p>输入<code>r</code>：查看所有寄存器的值<br>输入<code>r 寄存器名称</code>：修改寄存器的值<br>输入<code>r ax</code>：将ax寄存器的值改为0100H<br><img src="https://img-blog.csdnimg.cn/766f633834b54ba9b27566c5b45d0287.png" alt="在这里插入图片描述"></p><h2 id="3-D命令"><a href="#3-D命令" class="headerlink" title="3. -D命令"></a>3. -D命令</h2><p>输入<code>d</code>：可以查看内存中的内容<br>输入<code>d 段地址:偏移地址</code>：查看特定位置的内存数据<br>输入<code>d 段地址:起始偏移地址 结尾偏移地址</code>：查看特定位置和特定范围的内存数据<br>输入<code>d 偏移地址</code>、 <code>d 起始偏移地址 结尾偏移地址</code>：会将DS的内容作为段地址  </p><p><img src="https://img-blog.csdnimg.cn/787cf3e1950f46f5b19fea11d0f62843.png" alt="在这里插入图片描述"></p><p>右边是每个内存单元中的数据对应的可显示的ASCII码字符，如果没有对应的ASCII字符，就显示“.”。</p><h2 id="4-E命令"><a href="#4-E命令" class="headerlink" title="4. -E命令"></a>4. -E命令</h2><p>1、输入<code>e 段地址:偏移地址 数据串</code>修改特定位置的内存数据：<br><img src="https://img-blog.csdnimg.cn/429434b7cb61433fa575ee970a227fff.png" alt="在这里插入图片描述"><br>2、输入<code>e 段地址:偏移地址</code>后按Enter也可以修改特定位置的内存数据，数据之间用空格隔开：<br><img src="https://img-blog.csdnimg.cn/361619e10b5645b8b89c055ae127ceaa.png" alt="在这里插入图片描述"></p><h2 id="5-U命令"><a href="#5-U命令" class="headerlink" title="5. -U命令"></a>5. -U命令</h2><p>输入<code>u</code>、<code>u 段地址:偏移地址</code>可以将内存中的内容翻译为对应的汇编指令：<br><img src="https://img-blog.csdnimg.cn/7e5c84f72e60412c9c4955302fcee21a.png" alt="在这里插入图片描述">由3部分组成</p><blockquote><p>1、最左边一列：是指令的地址<code>段地址:偏移地址</code><br>2、中间那一列：是指令对应的机器指令<br>3、最右边一列：是汇编指令</p></blockquote><h2 id="6-A命令"><a href="#6-A命令" class="headerlink" title="6. -A命令"></a>6. -A命令</h2><p>输入<code>a</code>、a 段地址:偏移地址<code>在这里插入代码片</code>可以从某位置开始写入汇编指令：<br><img src="https://img-blog.csdnimg.cn/0848a6e92a9b4af09de93e2d80f3fa2d.png" alt="在这里插入图片描述"></p><h2 id="7-T-执行机器指令"><a href="#7-T-执行机器指令" class="headerlink" title="7. -T 执行机器指令"></a>7. -T 执行机器指令</h2><p><img src="/../../../assets/Pasted%20image%2020221201161730.png"></p><h2 id="8-G-从指定地址开始直到断点或正常结束"><a href="#8-G-从指定地址开始直到断点或正常结束" class="headerlink" title="8. -G 从指定地址开始直到断点或正常结束"></a>8. -G 从指定地址开始直到断点或正常结束</h2><p><img src="/../../../assets/Pasted%20image%2020221201161736.png"></p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>本篇文章转载自 <a href="https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html">https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html</a><br>结合文章做了一些小修改，使文章更完整。</p><h2 id="1-总线"><a href="#1-总线" class="headerlink" title="1 总线"></a>1 总线</h2><p>只是想了解寄存器知识的话，只要看这一段就好：CPU与内存之间的通信采用总线的方式，其中总线又分为三种：<strong>数据总线</strong>（用来传输数据）、<strong>地址总线</strong>（确定将数据传输到什么地方）、<strong>控制总线</strong>（确定哪个设备需要传输数据）</p><p>计算机五大组成部分是：<strong>控制器、运算器、存储器、输入设备和输出设备</strong>。CPU所代表的控制器和运算器需要和存储器（主内存），以及输入设备和输出设备进行通信。通信采用的方式就是总线。</p><p>总线，其实就是一条线路。CPU、内存、以及输入和输出设备，都是通过这组线路进行相互间通信的。总线的英文叫做Bus，就是一辆公交车。这个名字很好地描述了总线的含义。我们的公交车的各个站点，就是各个接入设备（键盘、鼠标、显示器、硬盘、乃至通过USB接口连接的外部设备）。想要向一个设备传输数据，我们只要把数据放在公交车，在对应的车站将数据放下就好。</p><p>现代 Intel CPU 的体系结构里面，通常有好几条总线。</p><p>首先，<strong>CPU 和内存</strong>以及 <strong>CPU 和高速缓存</strong>之间采用不同的总线进行通信。这种方式，我们称之为双独立总线（Dual Independent Bus,DIB)。CPU 内部，有一个快速的<strong>本地总线</strong>（Local Bus)，也称之为后端总线（Back-side Bus),是 CPU 用来 和 CPU 内部的高速缓存之间进行通信，另一个速度较慢的<strong>前端总线</strong>（Front-side Bus)，也称之为处理器总线（Processor Bus)或内存总线（Memory Bus), 是 CPU 用来和主内存以及输入输出设备进行通信。  </p><p>从 CPU 硬件架构图可以看出，CPU 里面的<strong>北桥芯片</strong>，把之前说的前端总线，一分为二，变成了三个总线。前端总线其实就是系统总线。CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I&#x2F;O 桥接器（I&#x2F;O Bridge)。这个 I&#x2F;O 桥接器，一边接入了我们的内存总线，使得我们的 CPU 和内存通信； 另一边又接入了一个 I&#x2F;O 总线，用来连接 I&#x2F;O 设备。</p><p>事实上，真实的计算机里，前端总线层面拆分得更细，根据不同的设备，还会分成独立的 PCI 总线、ISA 总线等等。<br><img src="https://img-blog.csdnimg.cn/20200512104137989.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在物理层面，其实完全可以把总线看作一组”电线“。不过呢，这些电线之间也是有分工的，我们通常有三类线路。</p><ol><li><strong>数据线（Data Bus）</strong>，用来传输实际的数据,也就是公交车上实际坐的”人“。</li><li><strong>地址线（Address Bus)</strong>,用来确定到底把数据传输到哪里去，是内存的某个位置，还是某一个 I&#x2F;O 设备。也即”人“要下车的站点。</li><li><strong>控制线（Control Bus)</strong>,用来控制对于总线的访问。虽然我们把总线比喻成了一辆公交车。那么有人想要做公交车的时候，需要告诉公交车司机，这就是我们的控制信号。</li></ol><h2 id="2-CPU-发展史"><a href="#2-CPU-发展史" class="headerlink" title="2 CPU 发展史"></a>2 CPU 发展史</h2><p>Intel CPU 系列，最初是 4 位微处理器 4004，然后到到 8 位微处理器的 8008 ，再到 8 位微处理器 8080,以及稍后的 16 位微处理器 8086，由 8086 开始，Intel 进入现在所谓的 <strong>x86</strong> 时代 。Intel 8086 为 16 位 CPU ，而因为在 8086 之前的 CPU 都是 8 位 CPU，这样也就造成了很多的外设也只支持 8 位，因此 Intel 紧接着就退出了 8 位的 8088 CPU，因此 Intel 8088 也就可以看做是 8086 的 8 位版本；如果是但从汇编语言的角度上来说，8086 和 8088 是没有区别的，即 8086 上跑的程序可以不加修改的移植到 8088 ，8088 上跑的程序也可以不加修改的移植到 8086 上，当然，还是有些特殊的地方是不同的，而这些基本上在这里可以忽略掉，</p><p>在 8088 CPU 之后，Intel 又推出了 80186 ，80286 ，这两款 CPU 均是 16 位 CPU ，而对于 80186 来说，其与 8086 的区别可以简单的看做是 80186 多了几条指令而已，而 80286 则不同，80286 的地址总线数目有了变化，在 8086 , 8088 , 80186 上，CPU 的地址总线都是 20 根，即可最大寻址 2^20 即达到 1MB 的寻址能力，而对于 80286 CPU 来说，其地址总线数目达到了 24 根，从而最大寻址能力为 2^24 即 16MB，由于支持更多的物理内存寻址，因此 80286 便开始成为了多任务，多用户系统的核心。</p><p>而后来，Intel 又推出了 80386 ，80386 为 32 位微处理器，Intel 80x86 家族的 32 位微处理器始于 80386；同时 80386 也完全兼容先前的 8086&#x2F;8088，80186，80286，并且 80386 全面支持 32 位数据类型和 32 位操作，并且 80386 的数据总线根数和地址总线根数均达到了 32 根，从而可以最大物理寻址为 2^32 即 4GB 。</p><p>而之后的 80486 也是 32 位微处理器，而后又出来了 Pentium 和 Pentium Pro 等等第五代微处理器，这些处理器虽然也是 32 位微处理器，但是他们的数据总线和地址总线都有所扩展，比如 Pentium 的数据总线达到 64 位，而 Pentium Pro 的地址总线位数达到了 36 位 。</p><h2 id="3-寄存器"><a href="#3-寄存器" class="headerlink" title="3 寄存器"></a>3 寄存器</h2><p>寄存器是什么呢？其实很简单，寄存器就是个存储信息的单元或者说是器件又或者说是容器而已，<br>就比如内存也是一个存储介质或者说是存储单元而已，其实寄存器从理解上来说和内存差不多，</p><p>只不过寄存器（这里讨论的寄存器都是 CPU 中的寄存器，不包括外设上的寄存器）位于 CPU 内部，而内存位于 CPU 外部，</p><p>而且，寄存器比内存可是珍贵得多啊，就拿内存和硬盘来比，肯定是内存在使用上珍贵得多，是 PC 中的稀有资源，而寄存器是 CPU 中的稀有资源，内存和寄存器相比就像硬盘和内存相比一样。而对于一个汇编程序员来说，CPU 中主要可以使用的也就是寄存器而已，汇编程序员可以使用指令来读写 CPU 中的寄存器，</p><p>从而可以实现对于 CPU 的控制，当然，不同的 CPU ，寄存器的个数和结构都是不一样的，</p><p>8086 CPU 中寄存器总共为 14 个，且均为 16 位 。即 <strong>AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES</strong> 共 14 个。</p><p>而这&#x3D;&#x3D;14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。&#x3D;&#x3D;<br><img src="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>1 通用寄存器</strong></p><p>AX，BX，CX，DX 称作为数据寄存器</p><p>AX (Accumulator)：累加寄存器，也称之为累加器；</p><p>BX (Base)：基地址寄存器；</p><p>CX (Count)：计数器寄存器；</p><p>DX (Data)：数据寄存器；</p><p>SP 和 BP 又称作为指针寄存器</p><p>SP (Stack Pointer)：堆栈指针寄存器；</p><p>BP (Base Pointer)：基指针寄存器；</p><p>SI 和 DI 又称作为变址寄存器</p><p>SI (Source Index)：源变址寄存器；</p><p>DI (Destination Index)：目的变址寄存器；</p><p><strong>2 控制寄存器</strong></p><p>IP (Instruction Pointer)：指令指针寄存器；</p><p>FLAG：标志寄存器；</p><p><strong>3 段寄存器</strong></p><p>CS (Code Segment)：代码段寄存器；</p><p>DS (Data Segment)：数据段寄存器；</p><p>SS (Stack Segment)：堆栈段寄存器；</p><p>ES (Extra Segment)：附加段寄存器；</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>从上面可以知道，在 8086 CPU 中，通用寄存器有 8 个，分别是 AX，BX，CX，DX，SP，BP，SI，DI ，</p><p>至于为什么给它们取名做通用寄存器，那是因为，这些个寄存器多种用途，</p><p>比如 CX 作为计数寄存器，则是在使用 LOOP 指令循环时用来指定循环次数的寄存器，</p><p>如果它们每一个都只有一个专用的作用，那就它们只能称之为专用寄存器了，</p><p>正是因为这些个寄存器还可以用来传送数据和暂存数据，所以才称它们为通用寄存器 。</p><p>下面就按顺序来一一介绍这几个通用寄存器了：</p><p><strong>数据寄存器（AX，BX，CX，DX）：</strong></p><p>数据寄存器有 AX，BX，CX，DX 四个组成，</p><p>由于在 8086 之前的 CPU 为 8 位 CPU，所以为了兼容以前的 8 位程序，</p><p>在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，</p><p>由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了 。</p><p>AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；</p><p>BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；</p><p>CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；</p><p>DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；</p><p>除了上面 4 个数据寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器 ；</p><p>注意在上面标志中的“独立”二字，这两个字表明 AH 和 AL 作为 8 位寄存器使用时，</p><p>可以看做它们是互不相关的，也就是看做两个完全没有联系的寄存器 X 和 Y 即可，</p><p>比如指令 MOV AH , 12H ，CPU 在执行时根本就不会知道 AL 中是什么鬼东西，因为它只认识 AH 。</p><p>下面给出一幅 16 位数据寄存器的结构图：</p><p>表示 16 位 寄存器 AX 可以表示成两个 8 位寄存器，</p><p>其中 AH 表示高位的 8 位寄存器，AL 表示低位的 8 位寄存器 。<br><img src="https://img-blog.csdnimg.cn/20200512111614952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p><h4 id="AX-寄存器"><a href="#AX-寄存器" class="headerlink" title="AX 寄存器"></a>AX 寄存器</h4><p>如上所说，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL</p><p>AX 寄存器具有的特殊用途是在使用 DIV 和 MUL 指令时使用，</p><h5 id="DIV"><a href="#DIV" class="headerlink" title="DIV"></a>DIV</h5><p>DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的，而且除数可以存放在寄存器中或者是内存单元中，而至于被除数的话，自然，应该由 AX 来代替了，当除数是 8 位时，被除数一定会是 16 位的，并且默认是放在 AX 寄存器中，<br>而当除数是 16 位时，被除数一定是 32 位的，因为 AX 是 16 位寄存器，自然，放不下 32 位的被除数，<br>所以，在这里还需要使用另一个 16 位寄存器 DX ，其中 DX 存放 32 位的被除数的高 16 位，而 AX 则存放 32 位的被除数的低 16 位，</p><p>同时，AX 的作用还不仅仅是用来保存被除数的，当除法指令执行完成以后，如果除数是 8 位的，则在 AL 中会保存此次除法操作的商，而在 AH 中则会保存此次除法操作的余数，当然，如果除数是 16 位的话，则 AX 中会保存本次除法操作的商，而 DX 则保存本次除法操作的余数。</p><h5 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h5><p>当使用 MUL 做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位，如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中，</p><p>而如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个 16 位的则是位于 16 的寄存器中或者是某个内存字单元中。</p><p>同时，当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中，而如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，</p><p>其中，高位默认保存在 DX 中，而低位则默认保存在 AX 中。</p><p>AX 寄存器在 DIV 指令中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,0H;设置 32 位被除数的高 16 位为 0H</span><br><span class="line">MOV AX,8H;设置 32 位被除数的低 16 位为 8H</span><br><span class="line">MOV BX,2H;设置 16 位除数为 2H</span><br><span class="line">DIV BX       ;执行计算</span><br></pre></td></tr></table></figure><p>4 条语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512112128858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>AX 寄存器在 MUL 指令中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,800H;设置 16 位乘数为 800H</span><br><span class="line">MOV BX,100H;设置 16 位乘数为 100H</span><br><span class="line">MOV DX,0H;清空用来保存乘法结果的高 16 位    </span><br><span class="line">MUL BX       ;执行计算</span><br></pre></td></tr></table></figure><p>4 条语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512112236713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p><h4 id="BX-寄存器"><a href="#BX-寄存器" class="headerlink" title="BX 寄存器"></a>BX 寄存器</h4><p>首先可以明确的是，BX 作为数据寄存器，表明其是可以暂存一般的数据的，即在某种程度上，它和 AX 可以暂存一般性数据的功能是一样的，其同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即有 BH 和 BL，除了暂存一般性数据的功能外，BX 作为通用寄存器的一种，BX 主要还是用于其专属功能 – 寻址（寻址物理内存地址）上，</p><p>BX 寄存器中存放的数据一般是用来作为<strong>偏移地址</strong>使用的，何为偏移地址呢？既然是偏移地址的话，当然得有一个基地址了，而这个基地址其实就是<strong>段地址</strong>，这里就涉及到了段寄存器，当然，在介绍 BX 寄存器的时候，我不会去介绍段寄存器，上面提到 BX 的主要功能是用在寻址上，那么，其是如何寻址的呢？</p><p>而这里，我只点一下，在 8086 CPU 中，CPU 是根据 &lt;段地址：偏移地址&gt; 来进行寻址操作的，而 BX 中存放的数据表示的是偏移地址的话，自然，便可以通过 &lt;段地址：[BX]&gt; 的方式来完成寻址操作了。</p><p>为了介绍 BX 在寻址当中的作用，下面我给出一副示意图：<br><img src="https://img-blog.csdnimg.cn/20200512112423760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p><p>上面的示意图表示：可以令 BX &#x3D; 2，然后通过 DS : [BX] 来访问到内存中段地址为 DS，且偏移量为 2 的内存单元了。上面介绍的这种寻址方式是 BX 在寻址中最最简单的应用了，而对于稍微复杂的寻址方式，还可以依赖于 SI，DI，BP 等寄存器来一起完成。</p><p>BX 寄存器在寻址中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV BX,5H</span><br><span class="line">MOV AH,11H</span><br><span class="line">MOV AH,[BX];设置 AX 的值为偏移地址为 BX 中的值时所代表的内存单元</span><br></pre></td></tr></table></figure><p>3 条语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512112718487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上图可以看出，在偏移地址为 5 时的内存单元中的数据位 BBH，<br><img src="https://img-blog.csdnimg.cn/20200512112848384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>而从这幅图上面就可以看出，确实通过 [BX] 找到了偏移地址为 5 处的内存单元，并且将内存单元移入了 AH 中。</p><h4 id="CX-寄存器"><a href="#CX-寄存器" class="headerlink" title="CX 寄存器"></a>CX 寄存器</h4><p>CX 寄存器作为数据寄存器的一种呢，其同样具有和 AX，BX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，即有 CH 和 CL 两个 8 位寄存器，</p><p>当然，CX 也是有其专门的用途的，CX 中的 C 被翻译为 Counting 也就是计数器的功能，</p><p>当在汇编指令中使用<strong>循环 LOOP</strong> 指令时，可以通过 CX 来指定需要循环的次数，</p><p>而 CPU 在每一次执行 LOOP 指令的时候，都会做两件事：</p><p>一件就是令 CX &#x3D; CX – 1，即令 CX 计数器自动减去 1；还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，</p><p>当然如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令 。</p><p>CX 寄存器在循环中的使用（输出 5 个白底蓝字的 A）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,0B800H</span><br><span class="line">MOV DS,AX;使用 80x25 彩色字符模式，内存地址 0xB8000 - 0xBFFFFF</span><br><span class="line">MOV BX,0;从 0xB8000 开始</span><br><span class="line">MOV CX,5H;循环 5 次</span><br><span class="line">MOV DX,41H;A 的16 进制为 41H</span><br><span class="line">MOV AX,01110001B;显示白底蓝字</span><br><span class="line">s:  MOV [BX],DX;显示 ASCII 字符</span><br><span class="line">    ADD BX,1</span><br><span class="line">    MOV [BX],AX;设置字符显示属性</span><br><span class="line">    ADD BX,1</span><br><span class="line">LOOP s</span><br></pre></td></tr></table></figure><p>语句的执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200512113302361.png" alt="在这里插入图片描述">  </p><h4 id="DX-寄存器"><a href="#DX-寄存器" class="headerlink" title="DX 寄存器"></a>DX 寄存器</h4><p>DX 寄存器作为数据寄存器的一种，同样具有和 AX，BX，CX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，极有 DH 和 DL，同时，DX 作为一个通用寄存器的话，自然其还有其他的用途，而关于 DX 在其他方面的用途，</p><p>其实在前面介绍 AX 寄存器时便已经有所介绍了，即当在使用 DIV 指令进行除法运算时，如果除数为 16 位时，被除数将会是 32 位，而被除数的高 16 位就是存放在 DX 中，而且执行完 DIV 指令后，本次除法运算所产生的余数将会保存在 DX 中，同时，在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，那么相乘后产生的结果显然需要 32 位来保存，而这 32 位的结果的高 16 位就是存放在 DX 寄存器中。</p><p>DX 寄存器在 DIV 指令中的使用（即 2293812 &#x2F; 256 &#x3D; 8960 余数为 52）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,0023H;32 位被除数的高 16 位</span><br><span class="line">MOV AX,0034H;32 位被除数的低 16 位</span><br><span class="line">MOV BX,100H;16 的除数</span><br><span class="line">DIV BX  </span><br></pre></td></tr></table></figure><p>语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512113509221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><p>可以看到在语句结束以后，AX &#x3D; 2300H 即十进制的 8960，而 DX &#x3D; 34H即十进制的 52 和我们的结果是一致的。DX 寄存器在 MUL 指令中的使用则各位可以参考在 AX 中 MUL 运算的使用，这里就不贴出来了。</p><h4 id="指针寄存器（BP-SP）"><a href="#指针寄存器（BP-SP）" class="headerlink" title="指针寄存器（BP, SP）"></a>指针寄存器（BP, SP）</h4><p>8086 CPU 中的指针寄存器包括两个，即 SP 和 BP ，在这里呢，我先只对 BP 寄存器做介绍，因为 SP 寄存器实质上必须和 SS 段寄存器一起使用，所以，我将会把 SP 寄存器留到后面和 SS 段寄存器一起作介绍。</p><p>BP (Base Pointer)也就是&#x3D;&#x3D;基指针寄存器&#x3D;&#x3D;，它和其他的几个用来进行寻址操作所使用的寄存器（还有 BX，SI，DI）没有太大的区别。</p><p>首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用，</p><p>而后当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，那么如果在指令中没有明确或者说是显示的给出段地址时，段地址则使用默认的 SS 寄存器中的值（BX，SI，DI 会默认使用 DS 段寄存器），</p><p>比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，</p><p>所以，这里代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元，而如果单单是使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。</p><p>并且 <strong>BP 寄存器主要适用于给出堆栈中数据区的偏移，从而可以方便的实现直接存取堆栈中的数据</strong></p><p>在 8086 CPU 中，只有 4 个寄存器可以以 […] 的方式使用，这四个寄存器分别是 BX，SI，DI，BP。</p><p>下面的 Demo 是 BP 寄存器在寻址中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV BP,0</span><br><span class="line">MOV AX,[BP]         ;将 SS:[BP] 代表的内存单元移入 AX 中</span><br><span class="line">MOV AX,CS:[BP]      ;将 CS:[BP] 代表的内存单元移入 AX 中</span><br></pre></td></tr></table></figure><p>语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/2020051211463534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><h4 id="变址寄存器（SI，DI）"><a href="#变址寄存器（SI，DI）" class="headerlink" title="变址寄存器（SI，DI）"></a>变址寄存器（SI，DI）</h4><p>首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。</p><p>SI (Source Index) 是源变址寄存器，DI (Destination Index) 即是目的变址寄存器，</p><p>8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器，而这也就是 SI 寄存器和 DI 寄存器与BX 寄存器所不同的地方，既然，SI，DI 两个寄存器的功能和 BX 差不多，自然，SI 和 DI 中也是可以暂存一般性数据的，同时，通过使用 SI 和 DI 寄存器也是可以用来完成寻址操作的。<br>比如下面的代码就是可行的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV SI,0;初始化偏移地址为 0</span><br><span class="line">MOV AX,[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[SI];将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DI,0    ;初始化偏移地址为 0</span><br><span class="line">MOV AX,[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[DI];将段地址为 SS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure><h3 id="CS-IP-SS-SP-DS-ES-寄存器"><a href="#CS-IP-SS-SP-DS-ES-寄存器" class="headerlink" title="CS, IP, SS, SP, DS, ES 寄存器"></a>CS, IP, SS, SP, DS, ES 寄存器</h3><p>由于段寄存器总是和其他一些像指针寄存器，变址寄存器，控制寄存器一起使用，所以在这里，我并不会单独介绍段寄存器，而是将段寄存器和一些其他的常用寄存器搭配介绍 。由于下面的介绍中会涉及到很多关于段和栈的概念，而段和栈的介绍又都必须关系到物理内存，所以在介绍段寄存器以及其他一些呈协作关系的寄存器之前，还是先来介绍一下这几个基本的概念比较好。</p><p><strong>8086 CPU 访问内存（物理地址）：</strong></p><p>当 CPU 需要访问一个内存单元时，需要给出内存单元的地址，而每一个内存单元在物理内存空间中都有一个唯一的地址，即可以通过这个地址定位到内存单元，而这个地址即为物理地址。CPU 通过地址总线将一个内存单元的物理地址送入存储器，而后 CPU 便可以通过这个物理地址来访问这个物理地址所指向的内存单元了。那么这个物理地址在 CPU 中是如何形成的呢？</p><p>首先，我们知道 8086 CPU 的地址总线是 20 根，即每次都可以传输 20 位的地址，从而寻址能力有 2^20 也就是 1MB 的大小，但是 8086 CPU 的寄存器只有 16 位，也就是在 8086 CPU 的内部，一次性处理，传输，暂存的地址都只能是 16 位，即 8086 CPU 不能完整的保存下一个物理地址（物理地址为 20 位），</p><p>如果单单以最简单的方式（即直接用 16 位寄存器来保存物理地址）的话，那么，寻址能力只有 2^16 ，也就是 64KB，如果真以如此简单的方式的话，那么地址总线还需要 20 根干嘛呢？而且，难不成我们以后的内存就是 64KB 了吗？</p><p>当然不是的，8086 CPU 在这里采取了一定的措施从而使其寻址能力达到 1MB 。8086 CPU 在内部通过<strong>两个 16 位的地址进行合成从而形成一个 20 位的物理地址</strong>，由此，8086 CPU 的寻址能力便可以达到 1MB 。</p><p>那么 8086 CPU 又是如何将两个 16 位的地址合成为一个20 位的物理地址的呢？当 CPU 在访问内存时，其会使用一个 <strong>16 位的基地址</strong>，然后再使用一个<strong>16 位的偏移地址</strong></p><p>通过将基地址和偏移地址传入 8086 CPU 的地址加法器中进行合成即可以构造出 20 位的物理地址。至于合成的方式如下：</p><p>基地址其实是通过一个 16 位的段地址来形成的，将一个段地址左移 4 位即形成了基地址，而至于偏移地址的话，自然不必多说，为 16 位，通过将基地址和偏移地址相加便形成了 20 位的物理地址 。</p><p>下面给出一幅示意图来表示物理地址的合成：<br><img src="https://img-blog.csdnimg.cn/20200512115455811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><h5 id="段"><a href="#段" class="headerlink" title="段"></a>段</h5><p>至于段的话，其实在物理内存中是没有段这一概念的，事实上，段的概念来自于 CPU ，因为 CPU 拥有段寄存器，既然在 CPU 中拥有了段寄存器，自然，在 CPU 中就肯定有段的概念了，其实段也就是在编程时，我们将若干个地址连续的内存单元看做是一个段，然后通过将一个段地址左移 4 位形成基地址，再通过这个基地址来定位这个段的起始地址，然后，再通过偏移地址便可以精确定位到段中的内存单元了，由于段的起始地址是一个段地址左移 4 位，</p><p>所以很明显，段的起始地址肯定是 16 的倍数，而且由于一个段内部，只能通过偏移地址来定位，而偏移地址为 16 位，所以一个段的长度也就是 2^16 也就是 64KB 的大小。</p><p>在编程时，可以讲一段内存定义成为一个段，而这里，我们又可以引出数据段，代码段，栈段这三种类型的段。何为数据段呢？其实就是我们自个儿定义一段内存（当然段起始地址肯定是 16 的倍数，并且段长度 &lt;&#x3D; 64KB），</p><p>然后我们在这个段里头存放我们所需要使用的数据，这就是数据段；何为代码段呢？其实也很简单，也是我们自己在编程的时候定义一段内存，然后这段内存用来存放我们的代码（也就是指令），既然是存放的代码，自然就称之为代码段；</p><p>何为栈段呢？至于栈段的话，有接触过数据结构的朋友应该是很清楚栈的，而这里我们也就是在内存中分配出一个段，然后将这个段当做栈来使用。</p><p>首先，对于任何一个段来说，均有段地址，而这些段地址是存放在段寄存器中（段寄存器的作用也在于此），但是对于不同的段，它们默认的段地址存放在不同的段寄存器中，像数据段来说，它的段地址存放在 DS （Data Segment）寄存器中，代码段的段地址存放在 CS （Code Segment）寄存器中，栈段的段地址存放在 SS （Stack Segment）寄存器中 。</p><p>下面给出一幅在段中寻址的示意图：<br><img src="https://img-blog.csdnimg.cn/20200512115812990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的示意图中，通过将段地址左移四位，然后与偏移地址相加便可以得到 20 位的物理地址了 。</p><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>8086 CPU 中提供了对栈的支持，并且其还提供了相应的指令来以栈的方式访问内存空间 。</p><p>什么是栈？通过上面在段中的介绍，栈其实就是一个段，再说白一点，也就是一块内存，当然，这块内存是一块连续的内存 。</p><p>既然栈是一个段的话，那么当然就可以以使用段的方式来使用栈，当然，除了像段一样的使用栈以外，栈还提供了其特殊的访问方式。</p><p>众所周知，栈是先进后出类型的数据结构，在 8086 CPU 中也是如此，可以通过&#x3D;&#x3D;PUSH&#x3D;&#x3D;指令将数据压入栈中，然后再通过&#x3D;&#x3D;POP&#x3D;&#x3D;指令将栈顶的元素取出来 。</p><p>下面给出一幅示意图来描述栈：<br><img src="https://img-blog.csdnimg.cn/20200512115902282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><p>即通过 PUSH 10 来将元素 10 放入栈中，因为，先前栈中没有任何数据，所以，10 就会作为栈顶元素存在，然后再在栈中压入元素 20 ，此时，栈顶中的元素就是 20 了，然后再使用 POP 指令将栈顶元素取出，此时取出的栈顶元素是 20 ，取出 20 后，栈中便只剩下 10 了，自然 10 就成为了栈顶，最后再通过 POP 指令将栈顶 10 取出，此时，栈便变成了空栈了 。</p><p>好了，在介绍段寄存器之前的基础知识介绍就到这里了，下面开始正式介绍段寄存器以及与它们协作使用的寄存器。</p><h5 id="CS-寄存器-和-IP-寄存器"><a href="#CS-寄存器-和-IP-寄存器" class="headerlink" title="CS 寄存器 和 IP 寄存器"></a>CS 寄存器 和 IP 寄存器</h5><p>经过前面对段的介绍，相信各位朋友对段寄存器应该也有一定的了解了，下面将要介绍的是一组非常非常重要的寄存器，即 CS:IP 。CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 CS 为代码段寄存器，而 IP 为指令指针寄存器 。</p><p>什么叫做指示了 CPU 当前将要读取的指令呢？在 8086 CPU 中，为什么 CPU 会自动的执行指令呢？这些指令肯定是存放在内存中的，但是 CPU 怎么知道这些指令存放在内存的那个位置呢？</p><p>比如，我有下面的两条指令要执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,1234H</span><br><span class="line">MOV BX,AX</span><br></pre></td></tr></table></figure><p>而假设这两条指令在内存中存放为：<br><img src="https://img-blog.csdnimg.cn/20200512120040942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>很显然， 1000H:0000H 指向的是 MOV AX，1234H 的首地址，如果 CPU 要读取到我的指令的话，很显然，必须要知道地址 1000H:0000H ，然后 CPU 就可以根据这个首地址，将汇编指令 MOV AX，1234H 所对应的机器码读入到 CPU 的指令寄存器中，最后便可以在 CPU 中进行处理了。</p><p>但关键是 CPU 如何知道我的 1000H:0000H 这个首地址？其实这就需要使用到 CS:IP 这个寄存器组了 。</p><p>当我们运行一个可执行文件时，很明显，我们需要另外一个程序来将这个可执行文件加载到内存当中，关于这个加载可执行文件的程序，我们在这里不管他，点一下即可，一般是通过操作系统的外壳程序（也就是传说中的 Shell 程序），Shell 将可执行文件加载到内存中以后，就会设置 CPU 中的两个寄存器，即设置 CS:IP 两个寄存器指向可执行文件的起始地址，此后 CPU 便从这个起始地址开始读取内存中的指令，并且执行，</p><p>比如我们在写汇编程序时，通常会使用 START 标记，其实这个标记就是用来标记起始地址的，当将一个汇编程序编译，连接成可执行文件以后，再通过操作系统的 Shell 程序将可执行文件加载到内存中以后，这个 START 所标记处的地址就是整个可执行文件的起始地址了 。</p><p>也就是说，当一个可执行文件加载到内存中以后，CS:IP 两个寄存器便指向了这个可执行文件的起始地址，然后 CPU 就可以从这个起始地址开始往下读取指令，<strong>当读取完指令后，CS:IP 将会自动的改变，基本上是改变 IP ，从而指向下一条要读取的指令</strong>，这样就可以执行这个可执行文件了 。</p><p>最后再对 CS:IP 总结一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.你想让  CPU  执行哪行指令，你就让  CS:IP  指向保存有指令的那块内存即可。</span><br><span class="line">2.任何时候，CS:IP  指向的地址中的内容都是  CPU  当前执行的指令。</span><br></pre></td></tr></table></figure><p>下面我们来看一个 Demo，并详细观察其执行的过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,1234H</span><br><span class="line">    MOV BX,AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200512120435345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面的截图中可以看出，当我使用 Shell （在 DOS 下也就是 Command 命令解释器）将可执行文件加载进内存后，可以看到，整个程序的起始地址为 0C54H : 0000 H ，并且，可以看到 CS 的地址为 0C54H ，IP 的地址为 0000H，这正好吻合我们上面对 CS:IP 的分析，很明显，CPU 将会读取 <code>MOV AX ，1234H</code> 到 CPU 中并且执行 ，</p><p>然后我们继续向下看：<br><img src="https://img-blog.csdnimg.cn/20200512120624853.png" alt="在这里插入图片描述"><br>可以看到，我们单步执行后，AX 中的值编成了 1234H ，而 IP 寄存器中的值变成了 0003H，对于 AX 中的值的改变，我们是能够理解的，但是 IP 中的值为什么会从 0000H 变到 0003H 呢？</p><p>从最上面的一幅关于指令在内存中的存放可以看出 <code>MOV AX ，1234H</code> 在内存中需要 3 个内存单元存放，也就是 CPU 为了执行 <code>MOV AX ，1234H</code> 这条指令，已经将内存中相对应的 3 个内存单元读入内存中了，执行完这条指令后，自然，CPU 就要将偏移地址向下移动 3 个单元，从而使得 CS:IP 指向下一条需要执行的指令了 ，</p><p>为了更深刻的理解，我们再来继续看执行过程，<br><img src="https://img-blog.csdnimg.cn/20200512121004851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从最上面的一幅关于指令在内存中的存放可以看出 <code>MOV BX ，AX</code> 在内存中只占 2 个内存单元，</p><p>这也就是为什么 IP 这一次只向下移动了 2 个单元的缘故 。</p><p>关于 CS: IP 的遐想：</p><p>从上面关于 CS:IP 的介绍中，我们可以大胆的猜想，我们<strong>只需要通过手动的改变 CS:IP 所指向的内存地址，让 CS:IP 指向我们另外的代码，那么我们就可以让 CPU 执行我们自己指定的代码了</strong>。即可以通过修改 CS:IP 来达到我们想要让 CPU 干什么它就干什么的目的 。</p><p>上面的虽然是遐想，但是大家要相信，我们写的是汇编，不是 JAVA 也不是 NET ，所以我们还真的可以达到上面的目的，也就是说我们的遐想其实是可以实现的，当然这还是有一定的限制的 ，</p><h5 id="SS-寄存器和-SP-寄存器"><a href="#SS-寄存器和-SP-寄存器" class="headerlink" title="SS 寄存器和 SP 寄存器"></a>SS 寄存器和 SP 寄存器</h5><p>在底层涉及的是栈在内存中的具体实现 。</p><p>不知道，大伙有没有注意笔者在本篇博文的上面介绍关于栈的知识时，我并没有提到如何找到这个栈，我只提到了一个栈就是先进后出操作，同时可以使用 ”PUSH“ 和 ”POP“ 指令，然后就是稍微带了一下 SS 这个寄存器的介绍，</p><p>我们虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给 CPU 使用的，既然 CPU 要使用的话，自然，CPU 又必须根据一定的方式找到这个栈，而这就需要使用 SS 和 SP 寄存器了 。</p><p>同时，一个栈也就是一块内存区域，通过上面的介绍，我们也知道了如果要在一块内存中精确地定位到内存单元的话（寻址），我们必须要有<strong>基地址（也就是段地址左移 4 位）和偏移地址</strong>，自然，要在一个栈中寻址的话，也需要段地址和偏移地址，</p><p>而对于一个栈来说，我们使用的最多的是什么呢？</p><p>当然是&#x3D;&#x3D;栈顶&#x3D;&#x3D;了，因为只有栈顶可以用来存取数据，所以对于一个栈来说，我们只需要有栈顶的段地址和偏移地址即可，而对于栈顶的段地址，其是存放在段寄存器 SS 中的，而对于栈顶的偏移地址，其则是存放在 SP 寄存器中的 。</p><p>&#x3D;&#x3D;在任何时刻，SS:SP 都是指向栈顶元素&#x3D;&#x3D;。</p><p>其实关于栈的使用还是比较简单的，但是要注意的是 8086 CPU 并不会保证我们对栈的操作会不会越界 。所以我们在使用栈的时候需要特别注意栈的越界问题 。</p><p>当使用 <code>PUSH</code> 指令向栈中压入 1 个字节单元时，SP &#x3D; SP - 1；即栈顶元素会发生变化；</p><p>而当使用 <code>PUSH</code> 指令向栈中压入 2 个字节的字单元时，SP &#x3D; SP – 2 ；即栈顶元素也要发生变化；</p><p>当使用 <code>POP</code> 指令从栈中弹出 1 个字节单元时， SP &#x3D; SP + 1；即栈顶元素会发生变化；</p><p>当使用 <code>POP</code> 指令从栈中弹出 2 个字节单元的字单元时， SP &#x3D; SP + 2 ；即栈顶元素会发生变化；</p><p>下面通过一个 Demo 来介绍栈的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,1000H;首先是定义好栈的段地址</span><br><span class="line">    MOV SS,AX    </span><br><span class="line">    MOV AX,10H;再定义好栈的长度（初始时刻的栈顶偏移地址即栈的长度）</span><br><span class="line">    MOV SP,AX</span><br><span class="line">    </span><br><span class="line">    MOV AX,0001H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0002H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0003H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0004H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0005H</span><br><span class="line">    PUSH AX</span><br><span class="line">    </span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p>然后我们来看栈在内存中的结构图：<br><img src="https://img-blog.csdnimg.cn/202005121216254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>语句的执行过程如下：<br>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="https://img-blog.csdnimg.cn/20200512121658415.png" alt="在这里插入图片描述"><br>然后我们再来依次执行上述指令：<br><img src="https://img-blog.csdnimg.cn/20200512121714142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上副截图中可以看出已经设置好了 SS:SP ，也就是栈已经设置 OK 了，</p><p>下面开始往栈中压入数据了，<br><img src="https://img-blog.csdnimg.cn/2020051212201138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于我们压入栈中的数据为字数据，即占 2 个内存单元，所以，每次 SP &#x3D; SP – 2 ；</p><p>将 5 个字型数据压入栈中后，我们可以来查看栈中的数据了，<br><img src="https://img-blog.csdnimg.cn/20200512122055548.png" alt="在这里插入图片描述"><br>因此，在内存中的一个好看点的结构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200512122124897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面开始进行出栈操作了<br><img src="https://img-blog.csdnimg.cn/2020051212215010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于我们弹出栈时的数据为字数据，即占 2 个内存单元，所以，每次 SP &#x3D; SP + 2 ；</p><p>将 5 个字型数据全部弹出栈中后，我们可以来查看栈中的数据了，<br><img src="https://img-blog.csdnimg.cn/20200512122206915.png" alt="在这里插入图片描述"><br>可以看到 SP 变成了初始状态了，也就是说栈中所有的数据已经全部弹出了，虽然我们查看内存时看到的不是 0 ，</p><p>但是我们看到的这些数据都是无效的，我们这里不理会 。</p><h5 id="DS-寄存器和-ES-寄存器"><a href="#DS-寄存器和-ES-寄存器" class="headerlink" title="DS 寄存器和 ES 寄存器"></a>DS 寄存器和 ES 寄存器</h5><p>DS 寄存器和 ES 寄存器都属于段寄存器，其实它们和 CS 寄存器以及 SS 寄存器用起来区别不大，既然是段寄存器的话，自然它们存放的就是某个段地址了 。</p><p>通过上面对基础知识的介绍呢，我们已经知道，如果 CPU 要访问一个内存单元时，我们必须要提供一个指向这个内存单元的物理地址给 CPU，而我们也知道在 8086 CPU 中，物理地址是由段地址左移 4 位，然后加上偏移地址形成的，所以，我们也就只需要提供段地址和偏移地址即 OK 。8086 CPU 呢，提供了一个 DS 寄存器，并且通常都是通过这个 DS 段寄存器来存放要访问的数据的段地址 。</p><p>DS（Data Segment）：很显然，DS 中存放的是数据段的段地址 。</p><p>但是这里不得不再点一下，那就是我们对段的支持是在 CPU 上体现的，而不是在内存中实现了段，所以事实上我们使用的段其实是一个逻辑概念，即是我们自己定义的，再说白了，我定义一个段，我说它是数据段那它就是数据段，我说它是代码段那么它就是代码段，它们其实都是一块连续的内存而已，至于为什么要区分为数据段和代码段，很明显，是用来给我们编程提供方便的，即我们在自己的思想上或者说是编码习惯上规定，</p><p>数据放数据段中，代码放代码段中 。而我们在使用数据段的时候，为了方便或者说是代码的编写方便起见，我们一般把数据段的段地址放在 DS 寄存器中，当然，如果你硬要觉得 DS 不顺眼，那你可以换个 ES 也是一样的，</p><p>至于 ES（Extra Segment） 段寄存器的话，自然，是一个附加段寄存器，如果再说得过分点，就当它是个扩展吧，当你发现，你几个段寄存器不够用的时候，你可以考虑使用 ES 段寄存器，在使用方式上，则和其他的段寄存器没什么区别 。</p><p>下面看一个介绍使用 DS 寄存器的 Demo：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">   </span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">    MOV AX,1000H</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    MOV AL,1</span><br><span class="line">    MOV BX,0</span><br><span class="line">    </span><br><span class="line">    MOV CX,5;设计一个循环，让其循环 5 次</span><br><span class="line">    s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">       INC AL</span><br><span class="line">       INC BX</span><br><span class="line">       LOOP s            </span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p>上面的代码所做的事情，就是循环将 1，2，3，4，5 写入到地址 1000H：0000H ，1000H：0001H，1000H：0002H，1000H：0003H，1000H：0004H 中，</p><p>语句的执行过程如下：<br>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="https://img-blog.csdnimg.cn/20200512122513469.png" alt="在这里插入图片描述"><br>而当循环执行完成以后，我们再来看内存 1000H：0000H 处的值：</p><p>在这里，我们可以看到确实达到了我们预期的效果，但是大家注意看代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">   INC AL</span><br><span class="line">   INC BX</span><br><span class="line">   LOOP s  </span><br></pre></td></tr></table></figure><p>这里可以看到，我们在 [BX] 中并没有给其指定段地址，而只有一个偏移地址，但是根据我们一开始的介绍，必须要有段地址和偏移地址才能够定位内存单元，</p><p>莫非这里出问题了？其实不是的，因为我们在最前面定义了段地址 DS 为 1000H，<strong>当我们定义好段地址后，每一次 CPU 执行到 [BX] 时，便会自动或者说是默认的从 DS 中取值</strong>，并且将取得的值作为段地址，因此，当 [BX] 为 0001H 时，CPU 会从 DS 中取得一个 1000H ，由这两个一合成即可以得到正确的物理地址 1000H：0000H 。</p><p>最后还提醒一点，那就是 8086 CPU <strong>不支持直接将一个数据送入段寄存器</strong>中，</p><p>也就是下面的做法是错误的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DS,1000H</span><br></pre></td></tr></table></figure><h5 id="标志寄存器-FLAG"><a href="#标志寄存器-FLAG" class="headerlink" title="标志寄存器 FLAG"></a>标志寄存器 FLAG</h5><p>前面呢，已经介绍了 8086 CPU 14 个寄存器中的 13 个了，下面我们将介绍最后一个寄存器也就是 FLAG 寄存器，FLAG 寄存器之所以放到最后一个介绍，是因为其和其他的一些寄存器不同，像 AX，BX，CX，DX 这些寄存器来说，它们都是用来存放数据的，当然 FLAG 中存放的也是数据啦，不过，AX，BX 这些寄存器中的数据是作为一个整体使用的，</p><p>最多也就分成一个 AL 和 AH 使用而已，<strong>但是在 FLAG 中，数据是按位起作用的，也就是说，FLAG 中的每一个位都表示不同的状态，由于一个位也就能表示 0 和 1</strong> ，自然，FLAG 中的每一个位就是用来描述状态的，而且 FLAG 寄存器中存储的信息通常又被称作程序状态字（PSW） 。</p><p>下面我给出一幅 FLAG 寄存器中各个位的示意图：<br><img src="https://img-blog.csdnimg.cn/20200512122743736.png" alt="在这里插入图片描述"><br>从上面这幅图中可以看出，FLAG 的第 0 个位表示的是 CF ，第 2 个位表示的是 PF ，与此类推 . . . .<br>首先，我们来看一个列表：<br><img src="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的这个表怎么看呢？我们通过看下面一幅截图就知道了 。<br><img src="https://img-blog.csdnimg.cn/20200512122828929.png" alt="在这里插入图片描述"><br>从上面的标记中可以看出，从左到右依次代表 OF，DF，SF，ZF，PF，CF 标志位的值，</p><p>至于为什么我们在 Debug 模式下，使用 R 命令时，只会列出这几个标志位，我猜的话是因为相对来说，列出的这几个标志位更为常用，其他的几个标志位并不经常使用的缘故吧 。</p><p>下面我们就按不同的位来分别介绍这些位所描述的状态，以及它们代表的意义：  </p><p><strong>CF（Carry FLag） - 进位标志（第 0 位）：</strong></p><p>CF： 进位标志是用来反映计算时是否产生了由低位向高位的<strong>进位</strong>，或者产生了从高位到低位的<strong>借位</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算过程中产生了进位或者借位)</span><br><span class="line">        CF  =  1;</span><br><span class="line">else</span><br><span class="line">        CF  =  0;</span><br></pre></td></tr></table></figure><p><strong>PF（Parity FLag） - 奇偶标志（第 2 位）：</strong><br>PF： 奇偶标志是用来记录相关指令执行后，其结果的所有的 Bit 位中 1 的个数是否为偶数 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算结果中 1 的个数为偶数)</span><br><span class="line">        PF  =  1;</span><br><span class="line">else</span><br><span class="line">        PF  =  0;</span><br></pre></td></tr></table></figure><p><strong>AF（Auxiliary Carry FLag） - 辅助进位标志（第 4 位）：</strong><br>AF： 用来辅助进位标志 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(字节操作中发生低半个字节向高半个字节借位或者进位  ||  字操作中发生低字节向高字节借位或者进位)</span><br><span class="line">       AF = 1;</span><br><span class="line">else</span><br><span class="line">       AF = 0;</span><br></pre></td></tr></table></figure><p><strong>ZF（Zero FLag） – 零标志（第 6 位）：</strong><br>ZF： 记录的是相关的指令执行完毕后，其执行的结果是否为 0 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(执行的结果  ==  0)</span><br><span class="line">       ZF = 1;</span><br><span class="line">else</span><br><span class="line">       ZF = 0;</span><br></pre></td></tr></table></figure><p><strong>SF（Sign FLag） - 符号标志（第 7 位）：</strong><br>SF： 符号标志，其记录相关指令执行完以后，其结果是否为负数 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算结果为负数)</span><br><span class="line">        SF  =  1;</span><br><span class="line">else</span><br><span class="line">        SF  =  0;</span><br></pre></td></tr></table></figure><p><strong>TF（Trap FLag） - 追踪标志（第 8 位）：</strong></p><p>TF： 追踪标志，主要是用于调试时使用 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(TF  ==  1)</span><br><span class="line">       CPU 进入单步方式;</span><br></pre></td></tr></table></figure><p><strong>IF（Interrupt-Enable FLag） - 中断允许标志（第 9 位）：</strong></p><p>IF： 中断允许标志，其决定 CPU 是否能够响应外部可屏蔽中断请求（以后会做详细介绍） 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(IF  ==  1)</span><br><span class="line">        CPU 能够响应外部的可屏蔽中断请求;</span><br><span class="line">else</span><br><span class="line">        CPU 不能够响应外部的可屏蔽中断请求;</span><br></pre></td></tr></table></figure><p><strong>DF（Direction FLag） - 方向标志（第 10 位）：</strong></p><p>DF： 方向标志，其用于在串处理指令中，用来控制每次操作后 SI 和 DI 是自增还是自减 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(DF == 0)</span><br><span class="line">        SI++,DI++;</span><br><span class="line">else</span><br><span class="line">        SI--,DI--;</span><br></pre></td></tr></table></figure><p><strong>OF（OverFlow FLag） - 溢出标志（第 11 位）：</strong></p><p>OF： 溢出标志，其通常记录了有符号数运算的结果是否发生了溢出 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算发生溢出)</span><br><span class="line">OF  =  1;</span><br><span class="line">else</span><br><span class="line">OF  =  0;</span><br></pre></td></tr></table></figure><h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>什么都不干顺下来就是顺序</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h3><p>利用Count寄存器CX存储循环次数，每次运行LOOP指令，将会执行：</p><ol><li>DEC CX（CX自减）</li><li>JUMP:MULTI</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS: CODESG</span><br><span class="line"></span><br><span class="line">CODESG SEGMENT</span><br><span class="line"></span><br><span class="line">    MAIN:  </span><br><span class="line">           MOV AX,2</span><br><span class="line">           MOV CX,11</span><br><span class="line">           MULTI:ADD AX,1</span><br><span class="line">           LOOP MULTI</span><br><span class="line">           </span><br><span class="line">           MOV AX,4C00H</span><br><span class="line">           INT 21H</span><br><span class="line"></span><br><span class="line">CODESG ENDS</span><br><span class="line"></span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><p>利用分支和JUMP循环</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="PROC（中断跳转）"><a href="#PROC（中断跳转）" class="headerlink" title="PROC（中断跳转）"></a>PROC（中断跳转）</h3><h3 id="小心SP的变化！"><a href="#小心SP的变化！" class="headerlink" title="小心SP的变化！"></a>小心SP的变化！</h3><p>首先：<br>cpu执行call指令时，相当于执行了（push ip） 和 （jmp near ptr 标号）：<br>(sp)&#x3D;(sp)−2<br>((ss)∗16+(sp))&#x3D;(ip)<br>(ip)&#x3D;(ip)+16位位移</p><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；<br>cpu执行ret指令时，(相当于pop ip)：<br>(ip)&#x3D;((ss)∗16+(sp))<br>(sp)&#x3D;(sp)+2</p><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。<br>cpu执行retf指令时，(相当于pop ip 和 pop cs)：<br>(ip)&#x3D;((ss)∗16+(sp))<br>(sp)&#x3D;(sp)+2<br>(cs)&#x3D;((ss)∗16+(sp))<br>(sp)&#x3D;(sp)+2</p><p>注：<br>SS是堆栈段寄存器，SP是堆栈指针寄存器。<br>SS * 16表示堆栈段的段地址（即堆栈段的起始地址），SS * 16+SP则表示堆栈的栈顶位置（地址）。<br><img src="/../../../assets/Pasted%20image%2020221201185743.png"></p><p>以上述代码段为例，调用过程为：<br>ip会指向下一条指令000E，<br><strong>将此时的000E推入push进栈，</strong><br>因为call指令 (ip)&#x3D;(ip)+16位位移 修改了ip的值，<br>相当于实现了段内跳转，<br>此时的位移： mov ax,4c00h（3个字节） 和 int 21h（2个字节） 两条指令，共5个字节，<br>所以ip &#x3D; 000Eh + 0005h &#x3D; 0013h, 刚好是 标号s 处地址，成功实现跳转。</p><p>此时成功跳转后，ip先指向下一条指令0015，<br>然后执行add指令，<br>执行成功后ip再指向下一条指令，这时会发现程序段中没有可指向的指令，但是仍会有指向，<br><strong>之后就会执行ret指令，将栈顶的000E出栈并用ip接收，</strong><br>这时就会发现无论之前的ip是多少，执行完ret后都会被覆盖，成功实现了跳转。</p><p>原文链接：<a href="https://blog.csdn.net/orange_monkey/article/details/106380255">https://blog.csdn.net/orange_monkey/article/details/106380255</a></p><h3 id="伪代码（可传参）"><a href="#伪代码（可传参）" class="headerlink" title="伪代码（可传参）"></a>伪代码（可传参）</h3>]]></content>
    
    
    <summary type="html">到处收集的汇编语言教程</summary>
    
    
    
    <category term="Coding" scheme="https://aleryxiao.github.io/categories/Coding/"/>
    
    
    <category term="ASM" scheme="https://aleryxiao.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>银之冠·碧之泪</title>
    <link href="https://aleryxiao.github.io/Tavg/SakuraR/bc91ebd0.html"/>
    <id>https://aleryxiao.github.io/Tavg/SakuraR/bc91ebd0.html</id>
    <published>2022-12-02T16:37:46.000Z</published>
    <updated>2023-01-02T14:07:00.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><p>总评：你在渴望着什么样的爱呢</p><ul><li>标签：R&#x2F;现代&#x2F;职场</li><li>篇幅：短篇</li><li>推荐：4&#x2F;5</li><li>*故事强度：4+&#x2F;5（5-清水 1-拔作）</li><li>*口味刺激性：2&#x2F;5（5-离谱 1-清水）<strong>（高浓度 NTR 警告!!!）</strong></li></ul><p><strong>故事背景</strong>（<strong>プロローグ</strong>）：</p><blockquote><p>千岁是个独居女OL，在酒店前台工作，正在与公司职员慎一郎恋爱中。故事的起点即是慎一郎与千岁求婚、千岁在犹豫着是否进入婚姻。其实，她和慎一郎很少见面，两个人都在工作上非常认真，她的工作决定了她不规则的工作时间、慎一郎则需要频繁的不定期出差，这也是她犹豫的原因之一。不过，后来千岁还是答应了，二人过上一段时间非常温馨的婚后生活。然而，好景不长，之后意外之事频繁地发生……</p></blockquote><p><strong>简评</strong></p><p>说到NTR，这可能会牵扯到很复杂的伦理问题，比如说婚姻关系中又遇到恋爱对象、婚姻关系不和睦的情况遇到恋爱对象。。。之类的。。不能说一段不成功的婚姻一定就得绑定一辈子吧，，可是要是误会呢，要是有一方多想呢。。什么什么什么的。。。（）这里我就绕开这点谈，因为我也不是很明白……又或者说这种事情里好坏完全就是模糊集吧，就是特别好和特别坏能分清楚，剩下的话只能按有些好的有些坏的这么谈了……</p><p>有的事可能局外的人看起来是离谱的，可是局内的人这么行动可能又是完全合乎情理的（…）但是合乎情理和对错好坏也不是能混为一谈的概念……</p><p>尤其是玩完这个游戏以后加强了我这种想法……刚开始我也觉得基本上应该是能分得出好坏的，这可是（）这还行（）这怎么能（）感觉谁这个做的不好谁那个又做的不好，可是后来想想我又并不是谁，不同的人就是会有不同的对事情的感受、考虑和处理事情的办法，用好不好、对不对之类的说法简单去评价感觉很困难呢……（不过我私心还是主要站女主角啦xd）</p><p>好复杂哦。总之，故事里的人是差不多合乎情理的吧……没有很重的强行NTR的感觉……</p><p>&#x3D;&#x3D;但是还是不建议感情洁癖的玩家去尝试了&#x3D;&#x3D;（或者这个能某种程度上治疗感情洁癖。。吗。。。。）</p><p>关于人物情感的表现也非常出色和细腻~后面细说~~</p><p>只是在氛围感上，由于故事的很大一部分埋没在OL女主角有点枯燥的生活里，没有很特别的地方，使得这个游戏有点缺乏自己的特色，不过这何尝不是一种特色（？）或者说，故事最大的特点就是平凡，男女主全员都是有些特点的普通的人，故事的环境也是普通中的普通，而慎一郎所做的事情、一件Routine中的意外、设定了故事发生的背景。虽然不知道是不是这样的故事真能发生在现实中，但是我觉得它也不乏合理性，在爱与婚姻的方面或许能给我们带来一些特别的感想吧（或许）。</p><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><h3 id="1-分线写点想写的"><a href="#1-分线写点想写的" class="headerlink" title="1. 分线写点想写的"></a>1. 分线写点想写的</h3><h4 id="a-千岁-amp-慎一郎"><a href="#a-千岁-amp-慎一郎" class="headerlink" title="a. 千岁&amp;慎一郎"></a>a. 千岁&amp;慎一郎</h4><p>慎一郎确实做得过分吧，对千岁完全实施保密主义，在网络时代连个简讯都不怎么愿意发……</p><p>不排除这可能是我这种对方没有秒回就会焦虑得要死的地雷元素阿宅的想法，或许就是有人是不太喜欢表达的吧……（默默想了一下我爸，一种很喜欢一发信息发几十行的中年男子，摇了摇头….我身边好像还真没有，草）</p><p>还是说只有小孩子才会觉得恋爱就是要天天联系天天发消息天天贴贴……我不觉得啊！至少在这个环节里，千岁体现出来的对能确认亲密关系的行为的需求在正常范围内，可是远远比慎一郎提供的一星半点要多。</p><p>而且，就算不能贴贴不能频繁联系，我坚信恋爱这种亲密关系的维持是以真诚坦诚多交流为基础的，解释一下总是可以的吧！！明明知道千岁不安的原因是什么，为什么一句都不愿意多解释，就看着她在那里沉浸在幻想的恐惧终吗，你也会雇保镖去守护千岁的人身安全呀，为什么不能关心一下千岁的心理感受呢……</p><p>受不了你了绿帽哥！！你完全是自作自受——！你这样除非你老婆真的是个逆来顺受的洋娃娃，就像你的线里一样每天上班下班回家等你，无条件的爱你理解你等待你，即使不安也相信你，肯定是会失去你老婆的啊……白痴吗你是……</p><p>或者说，千岁会走上NTR的道路，首先就是慎一郎对千岁缺乏她所必须的关怀，然后才是千岁自己有点纤细敏感。虽然直接走歪的鬼畜线我有点不能接受，但是她在受到幻想敌的凝视和伤害、不被新婚的丈夫关心和爱的恐惧中变得很脆弱，让她变得很脆弱因此迫切地想要找到可以依赖也会爱她的存在（一种感觉很容易坏掉的状态……），这听上去完全合乎情理吧……</p><p>我根本就不觉得千岁和慎一郎合适啊……不合适得有点难受的婚姻还是早点结束掉吧。甚至没领证，更方便了（。）还有千岁，还是不要那么草率地进入一段婚姻比较好吧……而且我一直不理解千岁到底喜欢慎一郎哪里，鬼畜线即使有点神经质地、以有点扭曲地方式在身体上索求着被爱的证明，依然强调着、看起来不太像是向自己强调这自己爱着慎一郎……</p><p>NTR作品看得实在太少了，同样感情脆弱的对象我只能想起来安乐冈花火……好像喜欢描写女性因为对自己被爱的能力没有安全感而病急乱投医（似乎我也能理解的样子）但是这样写起来太难过了。不过，故事里其他的对象我觉得都比慎一郎看起来顺眼，千岁这个医投得好像问题也不大，嘿嘿，就是过程折磨了一点。</p><p>说点题外的，我同情千岁，但是说不上对千岁……。明明在职场上做得那么好，是大家都敬佩的前辈，但是在爱情里看起来太不安脆弱、委曲求全了一点……而且，千岁的生活太单调了，也可能成为了她的脆弱的原因之一吧……我感受不到她在生活中有什么很喜欢做的事情，（虽然她自己说网购，但这只能说是让人高兴但是说不上是爱好吧……），看不到她对自己的生活有什么热情和希望，而是在婚后下意识地就完全在心理上依附于家庭生活，所以慎一郎对她所期望的生活的每一点背离都是对她沉重的伤害……也看不到她有什么好朋友，和自己的好朋友们有什么开心的生活。</p><p>我还是希望女主角能靠自己就把自己的生活过好呢，即使没有爱情也要能够开开心心地生活下去的那种。如果我是千岁的朋友的话，就带她一起打乙女游戏吧！！（？）要是她也喜欢的话，说不定就好朋友（我）和爱好（乙女游戏）都有了！！（？？）</p><h4 id="b-榛名诚"><a href="#b-榛名诚" class="headerlink" title="b. 榛名诚"></a>b. 榛名诚</h4><p>超喜欢的角色！……啊啊啊！！</p><blockquote><p>榛名：那个，因为姐姐你并不是很想结婚，所以这么说可能也并非出于本意。不过有的事情不做做看就不会知道吧?<br>千岁：话虽如此，但万一结婚后却发现不行，不是就无法挽回了吗?<br>榛名：正常地生活，然后发生无法挽回的事情，有那么常见吗? 只要活着的话怎样都行。这种思考方式不是也有吗?</p></blockquote><blockquote><p>榛名：姐姐，好像对得不到帮助这种事习以为常了呢。<br>千岁：……<br>榛名：还是说害怕?害怕被拒绝?<br>千岁：……<br>榛名：他的话锋太过尖锐，我不由倒吸口冷气。<br>确实，是这样。相信能被理解，期待得到帮助，却始终落空。每次都失望，已经习惯了放弃。<br>太悲惨了。而且，很悲哀…..<br>榛名：我说，必须要做那么善解人意的女人吗？我并不认为姐姐是在胡闹。那种程度，可以看做是在撒娇。</p></blockquote><p>喜欢他每天元气满满地面对兼职的快递工作，和大家都关系很好，（虽然自来熟得有点轻浮……（大概是剧情安排吧2333））喜欢他敏锐地发现千岁的不安、陪伴在千岁身边却不索求任何东西（好难过啊，不要白给啊年轻人qwq），喜欢他拉起大提琴的时候眼里有光的样子（虽然我也没有直接看到）。喜欢他笑起来的时候清脆的声音，喜欢他（）的时候压低的声音。</p><blockquote><p>榛名：大提琴的声音啊，是和人的声音非常接近的。因此如果用心去演奏，这家伙就会代替我歌唱。刚才，是以请姐姐振作起来的心情来演奏的。感觉到了吗?<br>千岁：嗯，感觉到了。<br>榛名：还有，最喜欢姐姐了!这样的心情也放进去了…..</p></blockquote><p>以及他这个人……成长历程顺风顺水锋芒毕露，直到让人感觉不适以后才收敛一点，也为此离开了家（唉…）；想要挑战所以学了不擅长的大提琴，一直这样拉着琴进了音乐学院，毕业了以后一边打工一边找乐团里的工作（因为位置很少所以很难找），独自住在海边不通电的小屋。一直没意识到自己喜欢音乐，直到自己有可能失去音乐。</p><p>我有过这样的梦哦，中学的时候吧，那个时候学钢琴也学得挺痛苦的，感觉对钢琴就是毫无感情（），能弹而已，赶紧考完业余的最高级就不学了，但是有天晚上突然梦见自己的手臂（不说具体了，有点血&#x2F;腥……），早上醒来感觉那个手都还是麻的，第一反应不是什么生活不便也不是什么不能写作业而是不能弹琴……那个时候我突然意识到可能我也还挺喜欢弹琴的。后来看了番剧四月谎，对钢琴的感觉更复杂了（）不过高中以后寄宿，到现在很久很久没有碰琴了，感觉也就慢慢淡了。</p><p>啊肯定没有诚的感触这么深啦，毕竟人家可是pro，不过这个故事让我想起了很有感慨的东西，不然我很久都不会想起来这件事了。还有顺风顺水什么的……我也谈不上一直很顺，大考唯一一次顺估计就是高考了，我的锋芒毕露都还没维持到被别人提醒要收敛的时候（。）但是不知道为什么我好像能理解诚的感受呢。</p><p>而且诚虽然很厉害但是看起来却很亲切！或者说，第一次认识诚就是从一个很亲切的角度，不是从他是个很会拉琴的人的角度，感觉他完全就是个普通的少年、不会有看到巨佬那种“啊、努力的天才！好厉害！不过我们的理解和感情可能存在巨大的鸿沟……”的又尊敬又有点想要退后的感觉。这样超棒的啊！</p><p>只是剧情里有个点比较难受。那天千岁在犹豫着留下他陪伴自己还是让他去尝试参加那个挺重要的比赛的时候。这并不是一个“要恋爱对象还是要追求梦想”的选择，其实感觉没那么严重，不陪女朋友女朋友也顶多就是不安一段时间（但是你们其实可以发消息的……），不去参加这个比赛的话以后也会有很多别的比赛，女朋友的选择就是一个可以刷好感（？）的地方……可是在这里却成为一个完全的转折点，明明只是一次性的选择却成为了一生的决定……</p><blockquote><p>我固执的将自己囚禁于寂寞之中，完全没有理会过榛名的事。正因为我什么都不管，榛名一定背负着许多痛苦和辛酸。<br>但是他却想要独自克服一切。<br>所以他演奏的音乐才如此坚强，因为懂得悲伤，所以才能这样温柔。<br>(……榛名)<br>我喜欢他的大提琴。喜欢他，喜欢到落泪。</p></blockquote><p>或者，希望他追求梦想的想法代表着一个愿意努力变得坚强的千岁，千岁会逐渐从失败的感情中恢复过来，然后两个人一起走向光明的未来；希望他留下来的想法代表着一个极端脆弱的千岁，即使留下来也无法缓解千岁的不安了，爱着千岁的诚放弃了一次比赛也就还会有下一次、一次又一次逐渐也就把对大提琴的爱也舍弃了……这份感情也就此背上了可能非常沉重的“代价”……</p><p><img src="/assets/Pasted%20image%2020221218003529.png"></p><p>还是拉着琴的诚最帅啦！青春最美好的还是追求理想而闪闪发光的样子呀！！</p><p>c. 和泉亮</p><p>突然发现我喜欢的全是故事里的年下系（<em>嘿嘿地笑了</em>）可能我还是比较排斥“大人らしい”的恋爱吧……</p><p>但是亮也很可爱诶！虽然这个人设好像有点普通没很多好说的（感觉是现实中也会存在的类型呢？）认真得有点固执的清纯男大学生（来了，某博主的二次元xp），但是也不会令人讨厌的刻板，感觉恰到好处……</p><p>等等，开了这个头发现真的没什么好说的。放绿江文就是标准的年下小狼狗设定啊（）不过这是好多好多年前的作品，那个时候可能没这么烂大街吧（沉思）可是这个人设它就算再烂大街写好了也还是香啊！！！呜呜呜。</p><p>亮，和我什么时候一起去吃拉面吧！！那个拉面真的听上去好好吃，能让我嗦一口吗qwq</p><p>d. 浅野&amp;神尾</p><p>年上系二人~一个无条件温柔得有点吓人，另一个对恋爱的需求有点大人气得吓人（）我都不感冒！！因为我喜欢！小孩子的恋爱！（？）</p><p>还有神尾我是真的不懂，对已经动心的女主狠心拒绝，过了两个月又逮住街上偶遇的女主激情告白……知道你是和自己内心斗争了，好吧，但是神尾感觉是个纯渣男啊，回心转意的原因完全不明，只是可能对之前的女孩子没有激情告白而已吧……我不知道，呜呜，我不懂，我只是觉得痛哭的千岁好惨，刚跟前夫吵完，又被新喜欢的人甩掉……</p><h3 id="2-总评"><a href="#2-总评" class="headerlink" title="2. 总评"></a>2. 总评</h3><p>本来想写一篇认真的评价的，但是不知道为什么就写得欢脱起来（最近好像都没写什么特别欢脱的评价呢？）……</p><p>想了很久给3+还是4-还是4虽然这几个没什么大区别，就是我觉得格局还是一股经典乙女游戏调调，女主虽然写了职场OL人设依然是每天情啊爱啊没有这些就过不下去了的样子，不过它讨论的东西确实是得R18才比较适合去理解吧……或者说主题正在与婚姻和爱和NTR，所以女主也是一个这种典型的脆弱的例子才行，故事才能这样展开？好像也有合理性……不过，比起一些少女童话，这本显然是要实在很多了（）而且有一些剧情也合理得让我有点小感动，这个就很棒啦。而且如果是因为少女童话感觉乏味的话，玩一下这个应该也很有趣吧！（虽然我也喜欢看少女童话，但是随着看的数目逐渐增多我也开始有点审美疲劳了……）</p><p>说到最后还是，希望女主这样的女孩子能找到属于且只属于自己的生活吧。把生活都围绕着男人和家庭确实是一种选择，可是万一选错了，那也太难过了。（）能够完全互相托付的爱情和婚姻我相信是存在的，可是一下子押上这样的赌注感觉有点危险呢……还是确保自己就算是一个人也能把生活过得丰富精彩比较好吧。（我觉得）还有，碰到慎一郎这种讲不通道理又不关心人的，要么想办法努力撬开他嘴（？）然后磨合磨合继续过日子，要么认识到不合适不接受早点润吧……</p>]]></content>
    
    
    <summary type="html">4/5 你在渴望着什么样的爱呢</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="SakuraR" scheme="https://aleryxiao.github.io/categories/Tavg/SakuraR/"/>
    
    
  </entry>
  
  <entry>
    <title>黑蝶幻境</title>
    <link href="https://aleryxiao.github.io/Tavg/Sakura/5c602a3a.html"/>
    <id>https://aleryxiao.github.io/Tavg/Sakura/5c602a3a.html</id>
    <published>2022-11-24T05:20:02.000Z</published>
    <updated>2023-01-02T14:07:00.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><p>总评：在幻境中寻找自我与真相</p><ul><li>标签：架空</li><li>推荐：4&#x2F;5</li><li>篇幅：中短篇</li></ul><p><strong>故事背景</strong>（<strong>プロローグ</strong>）：</p><blockquote><p>不明原因使得几人在失去记忆的情况下在一栋小洋楼中苏醒，要面对的是在建筑中游荡的怪物群。在这里，情感和思想能够转化为实质，他们在路遇的狐狸面具少年的战斗方式的启发下也利用“幻想”的手枪开始战斗。战败的怪物会化作黑色的蝴蝶散去，留下一种&lt;碎片&gt;。根据他们随身携带的手机上的信息，只要收集足够的&lt;碎片&gt;修复&lt;万花筒&gt;就能回到原来的世界……</p></blockquote><p><strong>简评</strong></p><ol><li>总体上逻辑自洽，主线剧情节奏也相当不错</li><li>只是以flowchart为主导的系统除了主线也有很多琐碎的短篇，每一篇单独阅读比较破碎和繁琐（但是也不是很不好，就是一些音乐听的太多了感觉人比较麻……）</li><li>全都不分线地喜欢女主（）（）（也不是什么……就是有点怪不好意思的……（？））女主是那种典型的温柔博爱型（有点审美疲劳了x）</li></ol><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><p>碎碎念：太好了，这游戏从打完到写repo又晾了大半个月，我的记忆正在快速褪色中……有的时候高密度打了很多个游戏，但是一时间又写不完repo，结果就像任务一样压在肩上让人很有排斥感（），现在还剩好多部（明明不是必须写的，可是，如果不写的话按我这个打的密度和忘的速度，会真正做到打过和没打过一样……）</p><h4 id="1-主线评价"><a href="#1-主线评价" class="headerlink" title="1. 主线评价"></a>1. 主线评价</h4><p>讲述了两次意外的故事。</p><p>黑蝶幻境是其中一次，让数年不愿相见或未能相见的几人重新相识、再次相聚，在探索的过程中逐渐发现另一次意外的真相，那几乎夺走了他们中两人的生命的一场意外，让剩下三个人自此背上不愿直面的&lt;罪&gt;，无法走出过去的阴影。</p><p>某种意义上，就好结局而论，可称为对余下三人的一种救赎吧……救赎的故事。</p><h4 id="2-写点想写的"><a href="#2-写点想写的" class="headerlink" title="2. 写点想写的"></a>2. 写点想写的</h4><h5 id="鉤翅-夏樹"><a href="#鉤翅-夏樹" class="headerlink" title="鉤翅 [夏樹]"></a>鉤翅 [夏樹]</h5><p>看上去是完美的温柔的青梅竹马…这种完美程度甚至会让人怀疑是否是那种游戏经典的切开黑……事实上，虽然说不上切开很黑，但是至少里面满满的是悲伤和痛苦吧。（声优太蛊了太蛊了，呜呜呜，好贴好贴！！）</p><p>他对绯影说，如果能够回到现实的话，他可以做一切能做的事情。在大家的背后，执着地追逐着所爱的身影，也因此与紋白分道……在有愿望又有希望（即使是虚假的）的情况下，封锁在这个洋楼里十多年，这样的执着怎么样能不变质啊。</p><p>能在所爱之人的面前维持最后的完美与温柔，并不是看上去那么轻松吧。花费多少自制力才能做得到呢。</p><p>可是游戏里，和已经死掉的人是没办法有真正意义上的好结局的。毕竟已经死掉的人，即使离开幻境，也没有归处了。要是那个雨天的夏树没有死在水里，他一定会和爱过上童话一样的幸福的生活的吧。IF线是真甜呀呜呜呜，可惜是IF……</p><p>真官配，也是真be…最让人叹惋的一条线。</p><h5 id="紋白-和也"><a href="#紋白-和也" class="headerlink" title="紋白 [和也]"></a>紋白 [和也]</h5><p>像是、实际上也是一簇连游荡的原因都已经忘却的游魂……拿着象征着执念的缎带，不知道从哪里来、也不知道是想要到哪里去。对爱孩子气的依恋并没有夏树那么重，也不愿意接受洋楼主人的约定，孤独地在洋楼里来去徘徊。</p><p>爱会伸手把他再次抱紧，接纳他的孤独与不安，接纳他再次展露的孩子气的依恋。作为友人也好，作为恋人也好。出于亏欠也好，出于同情也好，出于仍未消散的友情也好，还是出于爱恋，爱不在意，和也也不会在意了。只要此刻怀抱尚温，他就会像个孩子一样靠近过去。是啊，他本来也就是个孩子啊。和夏树一样，他们的时间早已在十多年前暂停了。</p><p>只是他的时间还能再续。他在现实还有归处，还能有一个与大家一同前进的未来。真好啊。（夏树：qaq）</p><h5 id="緋影"><a href="#緋影" class="headerlink" title="緋影"></a>緋影</h5><p>这位才是真疯皮（）关在这么个房子里！肯定是迟早会精神有点问题的啊！！！而且他关了那——么久啊（）</p><p>在这段漫长的时光开始之前，他就已经把自己的名字和样貌丢失了，也不再能想起，只记得要修复万花筒这件事。（虽然万花筒也是他自己打碎的……）连一直执念复活的妹妹就在身边也无法意识到。然后在漫长的时光里，一直把无辜的人拖下水替他寻找碎片……</p><p>怎么说…喜欢不起来啊（实在有点太疯了）再想想他和妹妹那段往事，妥妥的病娇啊（），惨是真的惨，狠也是真的狠，洗不白的那种（）我共情力下线了……</p><h5 id="山都-拓也-，鸦翅-明"><a href="#山都-拓也-，鸦翅-明" class="headerlink" title="山都[拓也]，鸦翅[明]"></a>山都[拓也]，鸦翅[明]</h5><p>二位我都不太有感（）虽然细谷和柿子都很萌是没错啦x</p><p>但是，被死掉的人完全绊住步伐十几年让我觉得很难受……那个事情是很难过，可是人总要往前看的呀。比起想着昨天做错了什么怎么做会更好，不如考虑怎么样弥补自己的错误、怎么样过好明天……（是我比较自私吗？）不去后悔应该算是我的一个强行设置的一个人生信条了……沉溺于后悔除了让人连第二天都过不好以外没有意义啊。</p><h3 id="3-和姐妹篇-lt-灰鹰幻境-gt"><a href="#3-和姐妹篇-lt-灰鹰幻境-gt" class="headerlink" title="3. 和姐妹篇&lt;灰鹰幻境&gt;"></a>3. 和姐妹篇&lt;灰鹰幻境&gt;</h3><p>感觉都是“人设 恋爱&lt;&lt;故事”的游戏，也是罕见的单线乙女游戏，游戏的设置就是让故事围绕探索主线去展开，而不是围绕着恋爱与人物展开。对人物的了解、恋爱关系的产生都是建立在故事的基础上的。</p><p>相比来说，黑蝶的故事更简单完整，灰鹰更复杂一点、只是半途加入很多魔幻设定让故事显得有点微妙。人设和恋爱上我觉得半斤八两，都是放了几个月就会让我几乎不记得多少的程度（……）但是灰鹰的女主朱德我更喜欢一点，感觉比爱的完美的博爱温柔更讨喜。</p><p>就是，还是觉得这两部在人设和恋爱上都没有做到很让人满意……不过，放眼到主流的人设与恋爱为主的众多乙女游戏，其中很多在主线的完整和自洽、以及探索主线的剧情节奏上都比不上黑蝶，女主每次都从头开始探索故事的内核，玩家明明有所了解却也要跟随女主的步伐，可是作为多视角游戏的优点（能够在不同的线里发掘不一样角度的真相，拼凑成一个完整的故事）由于对剧本要求比较高，也没有能体现出来，只不过是把同样的“真相”重复了一次又一次而已。</p><p>这里就体现出了单线乙女游戏的好处（）。不管怎么说，还是很希望看到各种各样的丰富形式的乙女游戏的~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无剧透篇&quot;&gt;&lt;a href=&quot;#无剧透篇&quot; class=&quot;headerlink&quot; title=&quot;无剧透篇&quot;&gt;&lt;/a&gt;无剧透篇&lt;/h2&gt;&lt;p&gt;总评：在幻境中寻找自我与真相&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标签：架空&lt;/li&gt;
&lt;li&gt;推荐：4&amp;#x2F;5&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Sakura" scheme="https://aleryxiao.github.io/categories/Tavg/Sakura/"/>
    
    
  </entry>
  
  <entry>
    <title>夜、灯す</title>
    <link href="https://aleryxiao.github.io/Tavg/Flos/dd119dd0.html"/>
    <id>https://aleryxiao.github.io/Tavg/Flos/dd119dd0.html</id>
    <published>2022-11-20T05:30:25.000Z</published>
    <updated>2023-01-02T19:08:30.507Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../../assets/2022112002221500.jpg"></p><h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><ul><li><p>简评：两代筝曲部少女们的决意与羁绊</p></li><li><p>标签：微恐&#x2F;百合&#x2F;校园</p></li><li><p>推荐：5-&#x2F;5</p></li><li><p>篇幅：8h±</p></li><li><p>背景（无剧透）：</p><blockquote><p>学校的旧楼里，曾经有一对不被接受的&lt;姐妹&gt;在走廊角落的房间殉情——从合宿惯例的鬼故事环节开始，筝曲部的少女们的暑假开始了。去往学校集训的过程中，事情的发展渐渐奇怪起来。旧楼里闪过的长发女高中生身影、诡异的琴声，以及与那个身影几乎完全重合的、不近人情的转校生：筝曲世家的大小姐。从部长开始，伙伴们接二连三地遇到死亡威胁……</p></blockquote></li><li><p>总评：</p><ul><li>恐怖程度非常之轻微，也几乎没有突然出现鬼脸的环节，非常友好，只有结尾和一些中途be可能出现有一点恐怖的立绘及cg（但是总体还是非常友好的！！）</li><li>剧情节奏控制得很好，不会让人觉得无聊也不会一直很紧张让人绷紧神经，少女们的日常非常温馨有趣，探寻真相的过程也是少女们互相解除心结的过程、徐徐道来循序渐进</li><li>人设非常细腻具体，少女们如何成为今天的模样、都有适度的插叙进行解释，（我愿成剧本为插叙大师——）在这个过程中，她们性格的变化和成长也逐渐显现出来。</li><li>一切在自然而然中有理有据地发生~</li></ul></li></ul><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><h3 id="1-简单来说"><a href="#1-简单来说" class="headerlink" title="1. 简单来说"></a>1. 简单来说</h3><p>喜欢！！！喜欢！！！总之就是非常非常喜欢！！！</p><h3 id="2-写写想写的"><a href="#2-写写想写的" class="headerlink" title="2. 写写想写的"></a>2. 写写想写的</h3><p>两代的姐妹都在相互救赎。不过，故事的视角更倾向于&lt;夜&gt;的那边，相比而言更加详细地描述了皇家两个少女的改变。</p><p>因为对音乐的执着所以强烈渴望着理想的境界，因为对理想境界的强烈渴望所以不愿停下步伐，难以被接近的优秀才能和强大的执念让她处在一种孤独之中。</p><p>&lt;夜&gt;遇到&lt;灯&gt;，终于在追求音乐的孤独的道路上找到了足以称之为旅伴的存在。孤独地一个人像唱片一样精确地弹着&lt;黑发&gt;的少女、为了追求完美与极致不惜一切代价的少女，内心的空洞之处被另一个少女的温暖填满了。</p><p>或许并不是没有人向小夜子传达过爱，可是执着于向前奔跑的小夜子无法看到路边的野花，也只有&lt;灯&gt;在具备追上她的步伐的同时将心意也传达。</p><p>所以对于小夜子来说灯音是唯一的不可替代的特别的存在。为了守护灯音、守护她们两个人同行的道路，她几近&lt;丧心病狂&gt;地做出可怕的事情……虽然灯音已经非常坚强，能够在&lt;姐姐&gt;面前忍耐着、独自承担下受到的所有伤害，但是这样趋于偏执的情感也注定是沉重的，当这份情感导致了无法挽回的后果的时候更是如此。小夜子的伦理与道德观念在偏执中被模糊，但灯音依然是清醒的。所以，那个校园怪谈般的结局也顺理成章。</p><p>对于铃和有华也有类似的情况。</p><p>有华也不是生来如此的。她也曾经渴望着伙伴，或者说她其实一直渴望着伙伴。也会因为父亲弟子的三言两语而痛苦。而小夜子就是她的孤独之中的救赎。</p><p>是小夜子的日记指引了有华，告诉迷茫的年幼的她，如果无法在他人身上寻求爱、那么干脆就一个人向着更远更理想的地方去吧，只要执着于手中的琴就足够，那也是一种选择；有华追逐着理想中的小夜子的身影，也和她一样踏上了一条孤独的道路。</p><blockquote><p>父：有華，对你来说音乐是什么。<br>有華：（问题被反问了，这让我有些生气。）<br>有華：音乐是我的道。是我应该笔直前进的道。然后我想到这条道的尽头去看看。<br>父：你的那条道路，只属于你一个人对吧。但是，你现在的演奏，像是在边燃烧道路两旁盛开的野花和美丽的樱花，一边向前行。为什么不能爱护一下路旁边的小花呢？给花浇点水，和飞来飞去的蝴蝶嬉戏，你不觉得那些时间会为你的道路增添色彩吗？<br>有華：我并不这么认为。这条路没有那样华丽而从容。因为只有奉献一切才能达到的高度，才是我向往的地方。<br>有華：（那天我不知不觉地焦虑起来，对于平时简单敷衍就能结束的说教，我不自觉地认真回答了。我已经做好了总有一天会变成那样的觉悟。）<br>有華：（我确信，就连血脉相连的亲人也不会理解我所走的路。）<br>父：当时筝曲是为一部分上流阶层而设的一种文化，皇道流的开山鼻祖大人主张「没有身份的隔阂，无论是谁都能享受」努力地向民间传播筝曲。<br>父：你不觉得你的发言是在侮辱那位开山鼻祖吗？你的意思可是筝只有被选中的人才能演奏，它应该是贵族才能碰的东西哟。<br>有華：即使是那样……<br>有華：（父亲平静而严厉地警告着我。但是，我不能在这里认输。…小夜子桑，请赐予我勇气。)<br>有華：即使是那样，我还是想到那条路的尽头去看看!这就是我作为演奏家的夙愿!<br>……然后也类似的，如同被命运所指引着一般，被铃所救赎。</p></blockquote><p>当两个故事相似重叠之时，不同之处才更加引人注目。</p><p>比起我们在故事里第一次遇见就是个成熟的独行者、拥有完美的世家大小姐礼仪、浑身散发着&lt;姐姐&gt;的气息的小夜子，看上去早已生根于自己选择的道路……</p><p>有华更像是个普通的、有点别扭的少女，虽然是大小姐却没什么大小姐架子，只是因为鲜少与人接触看起来不近人情（换句话说，让人感觉情商不是很高……）这一点或许与现代社会对世家之类的观念、对所谓的大小姐礼仪的弱化有关，也与有华自幼就避开了与他人产生交集这件事有关，小夜子桑那时的大小姐是绝对不能做出有华这种堪称任性的行为的吧（），也就自然在氛围的陶冶下拥有一副精致的大和抚子外壳；</p><p>虽然有华也会执着地向父亲诉说自己的志向，但那比起无法改变的偏执，更像是一种口号，像是在对着内心还哭泣着孤独不安与迷茫的自己用力地大声宣告。或许有华还没有碰上能够让她真正放弃追求着热闹与温暖的微小愿望的事情，只是沿着日记本里指出的一条存在的道路茫然地前行，想着，因为爱着音乐所以这样做应该就是对的。</p><p>小夜子和有华本来就是完完全全的两个人；她们生活在不同的时代，也有不太一样的性格。<br>（关于有华的想法的揣测纯属我个人说不出理由的猜测，如果不认同那就不认同吧~xd）<br>（不能说共情吧，但是我好像也有过类似的时期……只是我的才能完全比不上有华就是啦）</p><p><strong>更显然的是，这一代的&lt;夜&gt;与&lt;灯&gt;不再孤独。</strong></p><p>不像是几十年前的女校，在那里，少女们并不为追求音乐而选择音乐，走在那条道路上的只有孤独的她们而已；在这里，在筝曲部，她们可以互相陪伴。</p><p>同伴的存在让她们（尤其是本对“同伴”不甚理解的有华）不至于走向孤独而极端的道路，能够让她们与道路两旁盛开的野花一同前行。</p><p>野花虽然不是那么鲜艳但是野花也是鲜活的。</p><p>野花的存在是有意义的。</p><p>小夜子看不到野花。但是有华其实看到了野花。她说，奔跑的声音，无力的声音，空洞的声音，她听见了无法跟上自己步伐的少女们的感情，并且用她的方法尽可能地去指引着她们。很难说这件事情是出于什么，出于父亲的要求？出于突然的、亲近他人的善心？还是只是出于想要和铃一起奏乐的愿望？我觉得只是出于久旷的空虚的心。</p><p>小夜子和有华都很孤独，也都向往温暖：小夜子早就放弃了与普通的少女停下步伐一起喧闹的、鲜活又普通的温暖；而有华并没有真正遇到能让她放弃这些的理由，只是沿着小夜子的路在走着，这样脆弱的摇摆的心意被伙伴们的热闹所吸引了、改变了。</p><blockquote><p>有華：….我懂的。我是知道的啊。我对小夜子桑的想法。<br>有華：除了自己认为重要的东西以外，其他都是无聊的事情。即使将碍事的东西全都都烧尽，也能笔直地朝着目标跑下去…..<br>有華：现在，我也清楚的明白了，我也是一样的。我也是那样的人。我就是那样的人啊。我就是这样一直折磨着周围的人，折磨着家人….. !</p></blockquote><p>她也更容易能明白过来。</p><p>和有华自身的恐惧不同，我并不觉得有华会踏上和小夜子一样的道路，因为有华本就没有那么根深蒂固的偏执的理由，她只是迷茫而已。因为感受不到爱；因为手中只有琴，自己爱着琴，对琴的爱也会被琴接受；因为小夜子的日记告诉她，只有琴也是足够的。</p><p>这样的想法，让我觉得有华不会做出像小夜子一样的偏执的事情。</p><p>只看剧情不得而知小夜子这样强烈的偏执的产生具体的契机；又或者不需要什么契机，只是时也、运也罢了。</p><p>无论怎么说，拥有了许多伙伴的有华已经踏上了这条铺满鲜花的、颇有人间烟火气的道路，不再是漂浮一般身处于世间了。我由衷替她感到高兴。</p><p>在剧情里，野花们的表现也是相当亮眼的，而不只是作为夜与灯的陪衬而存在。她们是她们自己的故事的主角；只是，现在故事的主角视角是在夜与灯那边而已。</p><p>中间最喜欢的是丽子！其实在过程中就感觉丽子好像挺厉害的，整个探寻真相的过程中其实都是丽子在引导的，虽然说是“讨论”，那些便签纸上的1.2.3，大家的任务分工，都来源于她，丽子在好像不被人注意的角度引导着大家。所以被有華指明“空洞的声音”蕴藏的力量与恐惧时也没有觉得离谱，而之后给出的解释也是挺合理的。</p><p>想要被看到“我”本身的力量，却无法摆脱“我”身上所绑定的“他人”；如果被看见的不是“我”的话，那就干脆不要看见“我”好了。</p><p>听上去好难过啊。</p><p>不过由于接近结尾了，感觉写得有点小仓促……但是也不是什么大问题~我很喜欢丽子哦！</p><h3 id="3-关于少女们与救赎的歌谣"><a href="#3-关于少女们与救赎的歌谣" class="headerlink" title="3. 关于少女们与救赎的歌谣"></a>3. 关于少女们与救赎的歌谣</h3><p>并不是什么很新奇的故事。又或者说，故事还没开始很久，就能差不多猜到上一代姐妹间发生的旧事，关系很好的互相依靠着的两人、因为某些原因失去控制的&lt;姐姐&gt;、&lt;妹妹&gt;知道真相使得&lt;姐姐&gt;&#x2F;&lt;妹妹&gt;选择的结局……</p><p>但是这也不是为了探索真相而存在的故事。把真相全部告诉读者也毫无意义。故事的趣味正在与筝曲部的少女们一起跌跌撞撞地探索真相、互相治愈的过程。</p><p>细腻的细节，具体的情节，恰到好处的插叙，立体可感的人物设计，每个少女的心路历程都自然而然地展开，一直到达最后几人琴音和鸣的终点。两代姐妹的感情，还有结尾温暖的彩蛋。</p><p>像看了一场很美好的温馨的电影……作者也一定很爱这些角色吧，那些爱从字里行间都满溢出来……。</p><p>怎么能不喜欢！！怎么能不喜欢！！我超级喜欢！！我感动得想哭！！！！——！</p>]]></content>
    
    
    <summary type="html">5-/5 两代筝曲部少女们的决意与羁绊</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Flos" scheme="https://aleryxiao.github.io/categories/Tavg/Flos/"/>
    
    
  </entry>
  
  <entry>
    <title>Suicide_Club</title>
    <link href="https://aleryxiao.github.io/Tavg/SakuraA/9ce67f3c.html"/>
    <id>https://aleryxiao.github.io/Tavg/SakuraA/9ce67f3c.html</id>
    <published>2022-11-20T02:29:17.000Z</published>
    <updated>2023-01-02T14:07:00.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>难堪。真是太难堪了。<br>一边厌恶着人类，以一副早知自己的人生没有意义的样子对自己的生命嗤之以鼻……结果就是这个德行。<br>我难堪的样子真是太可悲了，一直蔑视生命的我其实根本无法放弃生命。<br>我是个没用的阴沉混蛋。一个无药可救的幼稚鬼。<br>而且很懦弱。<br>所以才会被他们的炙热情感所压制，只能找借口原谅「我放弃」都说不出口的自己。<br>而且——<br>在认清自己的同时，我第一次，对活着的人类产生了好奇。<br>我想要了解真正的他们。</p></blockquote><hr><blockquote><p>但即使如此，我也仍旧找不到任何能令他想要，「死掉一了百了」的主要原因。<br>话虽如此但我也丝毫不觉得，绘马同学的死的意志是虚假的，也不认为他是心灵过于脆弱而想要寻死。<br>世界没有两片相同的叶子。人也有人能承受的极限。就和世界各地湖泊的深度，广度和地底的形状都各不相同一般，人的精神构造也同样是独一无二的。自已觉得无所谓的针刺，也会有人被刺伤。自己看不见的獠牙，也有人可以看的一清二楚。<br>说不定，某处就存在着我无法察觉到，只有他才能看得见的死亡幻影。<br>而我…. .想要知道的就是这个。我想在他死前，稍微看一 下 只有他能看见的东西。</p></blockquote><p>　　‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;难堪。真是太难堪了。&lt;br&gt;一边厌恶着人类，以一副早知自己的人生没有意义的样子对自己的生命嗤之以鼻……结果就是这个德行。&lt;br&gt;我难堪的样子真是太可悲了，一直蔑视生命的我其实根本无法放弃生命。&lt;br&gt;我是个没用的阴沉混蛋。一个无药可救的幼稚鬼。&lt;b</summary>
      
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="SakuraA" scheme="https://aleryxiao.github.io/categories/Tavg/SakuraA/"/>
    
    
  </entry>
  
  <entry>
    <title>TBC_Diabolik Lovers</title>
    <link href="https://aleryxiao.github.io/Tavg/SakuraA/e2a2d525.html"/>
    <id>https://aleryxiao.github.io/Tavg/SakuraA/e2a2d525.html</id>
    <published>2022-11-20T02:29:09.000Z</published>
    <updated>2023-01-02T14:07:00.648Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>1作目</strong>: <a href="siyuan://blocks/20220930223958-jc908pl">DIABOLIK LOVERS LIMITED</a>**【PSP&#x2F;PSV】</p><p>2作目: DIABOLIK LOVERS MORE, BLOOD LIMITED【PSP&#x2F;PSV】</p><pre><code>PSP版2作目の移植です。無印から1か月後の話です。</code></pre><p>1&amp;2作目: DIABOLIK LOVERS GRAND EDITION【PS4&#x2F;SWITCH】</p><pre><code>シリーズ1作目とシリーズ2作目「MORE, BLOOD」が1本にまとまったものです。お得。今から初めて始めるなら「DIABOLIK LOVERS GRAND EDITION」1択です。）</code></pre><p>3作目: DIABOLIK LOVERS VANDEAD CARNIVAL (FD)【PSV】</p><pre><code>シリーズ2作目「MORE, BLOOD」のFDです。アドベンチャーパートとミニゲームがあります。</code></pre><p>4作目: DIABOLIK LOVERS DARK FATE【PSV】</p><pre><code>1作目2作目を踏まえた内容で、主人公と攻略対象が恋人同士でのスタートです。</code></pre><p>5作目: DIABOLIK LOVERS LUNATIC PARADE (FD)【PSV】**</p><pre><code>シリーズ4作目「DIABOLIK LOVERS DARK FATE」のFDです。*シリーズ3作目「DIABOLIK LOVERS VANDEAD CARNIVAL」のネタバレ~剧透~を含みます。</code></pre><p><strong>6作目: DIABOLIK LOVERS LOST EDEN【PSV】</strong></p><pre><code>新キャラ「キノ」が登場します。人間がヴァンパイアに殺されるという事件が起こります。</code></pre><p><strong>7作目: DIABOLIK LOVERS CHAOS LINEAGE【NS】</strong></p><pre><code>各キャラが「覇王」になるために争います。</code></pre></blockquote><p>　　‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1作目&lt;/strong&gt;: &lt;a href=&quot;siyuan://blocks/20220930223958-jc908pl&quot;&gt;DIABOLIK LOVERS LIMITED&lt;/a&gt;**【PSP&amp;#x2F;PSV】&lt;/p&gt;
&lt;p&gt;2作</summary>
      
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="SakuraA" scheme="https://aleryxiao.github.io/categories/Tavg/SakuraA/"/>
    
    
  </entry>
  
  <entry>
    <title>全员恶人</title>
    <link href="https://aleryxiao.github.io/Tavg/Sakura/b7813dd8.html"/>
    <id>https://aleryxiao.github.io/Tavg/Sakura/b7813dd8.html</id>
    <published>2022-11-20T02:27:38.000Z</published>
    <updated>2023-01-02T14:07:00.655Z</updated>
    
    <content type="html"><![CDATA[<ul><li>用时：28h</li><li>推荐：3&#x2F;5</li><li>总评：总体尚可，但谜底的设计不及谜面而稍让人失望。</li></ul><p>如果你要玩的话，简单给一些帮助（是我玩的时候需要却没找到的）：<br>分为共通4章节、每条个线A和B篇（B为后日谈）、两条真相线、许多EXTRA<br>（ <strong>EXTRA和B篇对完善人物形象和剧情几乎没有帮助</strong>，但是B篇不看完无法解锁真相线）</p><h3 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h3><h4 id="需要澄清的误解"><a href="#需要澄清的误解" class="headerlink" title="需要澄清的误解"></a>需要澄清的误解</h4><ol><li>如果你像我一样一开始觉得它真的是“全员恶人”的伙伴物语那我还是要提前说一下，呃，主角团生活的环境吧就还比较混沌，但是基本上是毫无疑问的大善人（），不是那种带感的搞事剧情来着……。</li><li>进去以后不要盯着アダム看2333男的闺蜜真不一定是反派……</li></ol><h4 id="不太满意的地方：（以及，听说英翻有问题，慎）"><a href="#不太满意的地方：（以及，听说英翻有问题，慎）" class="headerlink" title="不太满意的地方：（以及，听说英翻有问题，慎）"></a>不太满意的地方：（以及，听说英翻有问题，慎）</h4><ol><li><p>刚玩一两条个人线的时候我也想反驳“共通线和个人线脱节之类的”，第一条玩的是mozu线给我体验相当好。。然而，当你走完五条个人线发现个人线几乎没有新增的伏笔（……只有对应2-3小时不算复杂的小案件）然后来到真相线被报幕一样把真相没有实感地揭开……对不起，我也想说， <strong>高开低走</strong> 。<br> 我也在反思，为什么（类似说君雪、七罪）都是小案件累加我对这篇这么这么难以接受，现在想错就错在一开始就给我画了一个很大的饼，让我觉得存在一个非常强大难以战胜的庞大的黑暗组织，同时加上锁线时间，它的前期铺垫又非常非常的长。但是最后赢得太轻松，而组织的这几个特征都没有体现。 <strong>个线案件和主线案件的关联也并不存在，使得个线中为数不多的对主线的呼应非常单薄和生硬</strong> 。（这一点上可以看看终远的处理。）</p></li><li><p>成就系统。5条个人线无锁线关系，但是必须完成所有B篇才能打开真相线。怎么说呢，别的游戏锁线我都是理解的因为涉及“看了后面会影响前面的游戏体验”但是这个锁我属实难受，因为B篇是后日谈……当然不排除因为我有不喜欢的角色所以在这里无理取闹……一开始就没打算收集全成就，结果连真相线都差点进不去，EXTRA也开得不顺利，好难过，进一步导致我的剧情体验稀碎。</p></li></ol><h4 id="觉得挺好的地方："><a href="#觉得挺好的地方：" class="headerlink" title="觉得挺好的地方："></a>觉得挺好的地方：</h4><ol><li><p>熟悉的【伙伴的羁绊】类的剧情，非常温暖人心&gt;A&lt;而且没有什么糟心的误解敌对之类的，伙伴们一直是手牵手~我个人非常喜欢这种！</p></li><li><p>觉得玩到今天结局选项的逻辑性最强的乙女作……后面剧透篇再具体解释。是我一直期望看到的所以看到了甚至感觉到感动。</p></li><li><p>角色刻画很鲜明和细腻，总体上值得喜欢。女主角基本上可说是有智有勇，对待感情大大方方，积极努力向上，独立又可爱，嗯嗯，应该是那种不会踩雷的类型。</p></li></ol><h3 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h3><p>好感度lay：モズ＞＞シュウ＝リンボ＝スケアクロウ＞＞ヘルベチカ</p><p>有哪些东西给我留下了深刻的印象？</p><h4 id="1-结局选项逻辑我非常喜欢。"><a href="#1-结局选项逻辑我非常喜欢。" class="headerlink" title="1. 结局选项逻辑我非常喜欢。"></a>1. 结局选项逻辑我非常喜欢。</h4><p>クロちゃん的GE-BE分线点，女主是否自作主张不报暗号而是阻止他。其实小黑线可能还是多少有点让人生气吧，劝都劝不动感觉马上就要毁灭世界了，在此之前刚刚被女主拼死拼活救了又发疯快掐死女主（真的我有点生气！！）但是对小黑来说确实堵不如疏。女主有这个技能真是要谢天谢地。<br>リンボ的分线点，（说实话我觉得这里涉及的所有科技都给我感觉毫无真实感可言。。）女主是否选择放弃。Emm…我觉得女主如果放弃真的会崩人设，毕竟teuta积极向上一定会尝试解决方案的，リンボ看到这个得多绝望啊，她就算对反派言听计从リンボ也不会因此得救，如果不使用能力必是绝路。<br>シュウ的分线点，女主是否相信男主。（我就是想知道ヘルベチカ怎么能装成シュウ完全不被发现……）ヘルベチカ的分线点，女主是否曾经肯定过男主作为ヘルベチカ的存在、让他相信自己的意义（这个我觉得不是那么完美但是可以接受）。<br>最喜欢的是<strong>モズ</strong>线的分线点！我真的喜欢到感动。女主角遇见老师和少女两边都是危难情况，毫不犹豫地选择回溯。拿到手机给モズ打电话的时候思考：让モズ去救哪边？我玩得可能比较潦草，如果我是女主角我就猜不到有什么区别。<br>如果女主角选择モズ去救老师，モズ就会死，反之是皆大欢喜的结局。听上去是在巧合与意外中钦定死亡，其实不是。老师是假受伤，看到作为法医的モズ必然知道自己暴露（不排除モズ直接开口问……我感觉他不会这么做），故而捅伤モズ，但是看到女主角不会觉得有什么问题。怎么说呢，就是这种一念之差的选择决定了モズ和女主的命运让我觉得好难过。<br>我大概会一直记得モズ趴在地上微微抬起脸看着テウタ说：<br>然后微微笑起来。眼睛里的光渐渐散掉了。</p><h4 id="2-我好喜欢モズ。"><a href="#2-我好喜欢モズ。" class="headerlink" title="2. 我好喜欢モズ。"></a>2. 我好喜欢モズ。</h4><p>就是那种，让我无法移开目光的程度……即使是别人的线里。是少年成才的法医，对专业问题有个人的执着，从某些方面又体现出一种特别的“懵懂”，比如说在饭桌上放动物解剖图（女主问，就说：你不是也吃吗2333）、在大家吃饭的时候打电话聊工作（溶解尸体的话题……）并且说要去尸检所吃饭、说做饭和解剖没什么区别、说尸检所里的人“いるよ。たくさん。”……（大概有戳到我奇怪的萌点吧）。（说起来尸体是用“いる”的吗！！）<br>他看上去对于现实中的人格外的稚拙，但是其实什么都懂。我感觉他应该是这样的：一方面不考虑其他人对自己的评价（“我的专业水平和我的个人人格没有关系”），另一方面是在伙伴们面前更加放松直白地表达出自己……仔细一想他其实不考虑评价但是很在意他人的感受也很善良，会在节假日给同事替班，会原谅和安慰妹妹的朋友，会注视着反复穿越但是无法改变命运的テウタ说好好休息吧（ヘルベチカ线、好像是），会对着欺负（？）女主的ヘルベチカ在恋爱上发言。很多事情上也想得很多。<br>大概三次元中我也会喜欢这种类型吧。附加分，他甚至会做饭！！每次看到围裙モズ我都觉得好可爱呀！（……虽然 法医围裙？？）</p><h4 id="3-我好雷ヘルベチカ……"><a href="#3-我好雷ヘルベチカ……" class="headerlink" title="3. 我好雷ヘルベチカ……"></a>3. 我好雷ヘルベチカ……</h4><p>感觉自己被pua了……最难受的一条线……当然它这么让我难受，说明它刻画得相当立体……ヘルベチカ的自卑和自恋都让我觉得无所适从。……</p><h4 id="4-留下一些值得想一想的地方不过剧本没有细写。"><a href="#4-留下一些值得想一想的地方不过剧本没有细写。" class="headerlink" title="4. 留下一些值得想一想的地方不过剧本没有细写。"></a>4. 留下一些值得想一想的地方不过剧本没有细写。</h4><p>比如说女主为了拯救闺蜜的姓名而穿越、导致一个患者只能残疾、医生降职，这种“拯救”的矛盾点；比如说リンボ坚持程序正义（？）举报了同伴；比如说ヘルベチカ的童年，在这样的环境下成长而使得他人受到伤害的孩子应该怎么被评判……</p><h4 id="5-还有一些（可能我错漏了而）没有看明白的。"><a href="#5-还有一些（可能我错漏了而）没有看明白的。" class="headerlink" title="5. 还有一些（可能我错漏了而）没有看明白的。"></a>5. 还有一些（可能我错漏了而）没有看明白的。</h4><p>关于女主哥哥的暗线：<br>6年前试图（？）伤害女主但是伤害了ルカ之后挑衅アダム被アダム意外地……（导致アダム精神受创）之后交到（到底是谁啊？）モズ／トロイ那里分尸……？トロイ说自己被迫参与分尸的是谁啊？（还有为什么之前也没人查、这么无痕的吗……应该是因为network？）<br>イリナ的案子我也不是很懂……<br>アリケセイ的案子我也不是很懂，改头换面之类的是不是说的太超出我们的科技水平啦……Joker整一个莫名其妙（）。</p><p>大概就这些。简单记录一下了。之后就是下一本了_(:з)∠)_</p>]]></content>
    
    
    <summary type="html">3/5 总体尚可，但谜底的设计不及谜面而稍让人失望的（伪）悬疑剧。</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Sakura" scheme="https://aleryxiao.github.io/categories/Tavg/Sakura/"/>
    
    
  </entry>
  
  <entry>
    <title>君于雪中祈愿</title>
    <link href="https://aleryxiao.github.io/Tavg/Sakura/46b6220a.html"/>
    <id>https://aleryxiao.github.io/Tavg/Sakura/46b6220a.html</id>
    <published>2022-11-20T02:27:26.000Z</published>
    <updated>2023-01-02T14:07:00.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透"><a href="#无剧透" class="headerlink" title="无剧透"></a>无剧透</h2><ul><li>总评：与忘记感情的你解开宵祸之谜、共迎樱花开遍的江户春天。</li><li>标签：和风&#x2F;奇幻</li><li>推荐：3&#x2F;5</li><li>用时：35h（标程60h+）中长篇</li></ul><p>虽然感觉奇虚的设定会很虐但是<strong>其实几乎没有</strong>因为缺乏感情而<strong>虐的地方</strong> ，倒是有别的小虐点，林林总总也没到虐恋的程度（幻奏魔王 CM白石 那种程度标个虐我觉得还差不多）。</p><p><em>省流版：可以为了喜欢的声优冲刺，也可以纯纯地用来消磨时间（省略后句）不算惊艳但也能玩的日乙作品</em></p><table><thead><tr><th align="left"><span style="font-size: 15px;">篁 智成（小林裕介）</span></th><th align="center"><span style="text-align: start;">東条國孝（前野智昭）</span></th><th align="center"><span style="text-align: start;">与市（山下誠一郎&amp;nbsp;</span></th></tr></thead><tbody><tr><td align="left"><span style="font-size: 15px;">久賀源十郎（佐藤拓也 ）</span></td><td align="center"><span style="text-align: start;">錦次（浪川大輔 ）</span></td><td align="center"><span style="text-align: start;">桜太郎（斉藤壮馬）</span></td></tr></tbody></table><ol><li><p>女主设定不是非常讨喜。剧情设定决定女主在妖怪（宵祸）面前就是没办法有力地反击，而只能依赖于（来自血脉的）雪仪的力量（也无法自主训练）；某种程度上，她甚至没办法在面对困难的时候【相应地】提升自我，解决问题只能依靠与男主的爱和血脉。（……）</p></li><li><p>常见的案件切片再总写的结构，同CM终远七罪等等乙女游戏，是日乙非常常见的分线结构，就是在一个大反派（）的框架下面再支起来一些小反派，每个个人线去解决一个，这种结构给人的震撼力无非体现在：①玩家在不断深入真相（给出信息的“渐进”感，比如说个人线之间线索弥合） ②大反派设计的精妙（其实是剧情伏笔的精妙）（一般需要庞——大的真相才能给人更强的“恍然大悟”的感觉）。CM的生命力在小案件的生命力，终远好在庞大但基本自洽的世界框架，君雪相比来说没有哪方面特别突出……</p></li><li><p>你也说不出哪里很不好忍受不了，（而且每个个人线剧本都看得出来很认真，没有什么敷衍的）但是它做不到那么惊艳那么震撼让你久久难忘……不过人设做得挺好的。</p></li></ol><p>好感度：&#x3D;&#x3D;篁智成&#x3D;&#x3D;&gt;锦次&gt;樱太郎≈源十郎≈东条国孝&gt;与市</p><p>我发现我写专栏也没什么人看，但是每次分开讲角色线讲剧透篇都写得特别费劲（大概是那种能够感受到但是表达不好的类型），所以我大概以后看心情写角色线和剧透篇。（口语化的简单表达无法满足我对分析深度的要求，但是写深度分析太耗神了，超越了我对“记录”这件事的预设辛苦程度……）当然了也是因为这本游戏剧透篇也没什么特别特别的地方……</p>]]></content>
    
    
    <summary type="html">3/5 与忘记感情的你解开宵祸之谜、共迎樱花开遍的江户春天。</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Sakura" scheme="https://aleryxiao.github.io/categories/Tavg/Sakura/"/>
    
    
  </entry>
  
  <entry>
    <title>Paradigm Paradox</title>
    <link href="https://aleryxiao.github.io/Tavg/Sakura/737f7674.html"/>
    <id>https://aleryxiao.github.io/Tavg/Sakura/737f7674.html</id>
    <published>2022-11-19T09:36:21.000Z</published>
    <updated>2023-01-02T19:08:42.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../../assets/2022112009061000.jpg"></p><h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><ul><li><p>简评：和男高中生魔法少女一起拯救世界（？）</p></li><li><p>标签：魔法&#x2F;末日(?)</p></li><li><p>推荐：3-&#x2F;5</p></li><li><p>篇幅：长</p></li><li><p>背景：</p><blockquote><p>外面的世界的环境已不再适合人类生存了，ユウキ自小就在拥有穹顶的基地θ内生活。原本平凡的校园生活，在一次夜禁的意外滞留时发生转变：她被一种奇异的怪兽攻击了，醒来时就已身在&lt;研究区域&gt;，被告知&lt;超能力&gt;以及解决怪兽的魔法少女小分队Blooms的存在。随着与怪兽们、以及怪兽们之中接近人类的几人接触，本以为是&lt;正義の味方&gt;的她开始对这些&lt;真相&gt;产生怀疑……</p></blockquote></li><li><p>注意：</p><ul><li>8个人线+1大团圆线，平均不长、真相揭开速度也不快…个人感觉挺容易乏味的</li><li>一些线肉眼可见的敷衍…不敷衍的线的话，也就是差不多乙游平均偏上水平吧，没到特别惊艳的程度…</li><li>男主魔法少女化是<strong>女cv配音</strong>……而且魔法少女男主和日常男主<strong>从说话语气到人设都不一样</strong>（设定是：为了隐藏自己的身份……）我反正是很难把两个人设统一起来的（我也知道换女cv和说话语气有合理性，但是效果真的不好……）</li><li>真相展开速度慢（锁线少的游戏是这样的），不是很难猜…也不是很好玩，只能说勉强说得通</li><li>总之就是不建议为了几条达到均分的线买一整本游戏折磨自己…</li></ul></li></ul><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><h3 id="1-简评"><a href="#1-简评" class="headerlink" title="1. 简评"></a>1. 简评</h3><p>啊啊啊我先从正义侧开始打真的觉得这个游戏还行，没有之前玩的姐妹们评价得那么差，结果从会长线开始，然后恶的正义，哇，暴雷（<em>泪</em>），后面细说…</p><h3 id="2-各角色剧情再记录-部分吐槽"><a href="#2-各角色剧情再记录-部分吐槽" class="headerlink" title="2. 各角色剧情再记录+部分吐槽"></a>2. 各角色剧情再记录+部分吐槽</h3><p>按攻略顺序来说吧。游戏全程拖得有点久了，有些细节不一定记得很准确…</p><hr><p><strong>正義ルート</strong></p><h4 id="a-高遠トキオ"><a href="#a-高遠トキオ" class="headerlink" title="a. 高遠トキオ"></a>a. 高遠トキオ</h4><p>从声音到人设，感觉都很不错<del>（只是也没有到感动的程度啦233）<br>在研究员父母的爱里长大（虽然现在的实际相处模式比较像科学家的交流？）好像是个普普通通的学霸（这根本不普通啊啊啊什么人啊天天不上课，老师来问他他说啊那我就全部考满分行吗）……对身边的一切好像都淡淡的，只有谈到喜欢的科学领域的时候会显得有点高兴，不过也不是那种离谱的执念的程度。似乎是个挺理性的人，女主在这条线里相比来说就有点小矫情（矛盾硬凑……而且男女主小矛盾换成那种紧张刺激bgm真的好出戏）。<br>会在实验室里给头发夹小夹子，睡觉觉。啊那张睡醒睁眼的cg我愿给它封神（泪）真的好可爱好可爱。就是因为太牛逼了有点不亲切，要是能多写点就好了qwq<br>结局应该也是几条个人线里写的很好的，算是差不多把产生怪兽的原因也一锅端了，可喜可贺</del></p><h4 id="b-栖原カムイ"><a href="#b-栖原カムイ" class="headerlink" title="b. 栖原カムイ"></a>b. 栖原カムイ</h4><p>也挺喜欢的！是那种大大咧咧的轻浮（……）学长，和学校同学们都关系很好的样子，其实是拼命地满足着大家的愿望。在学业上普普通通，看上去傻乎乎又粗糙大条，细腻地爱着自己的家人……感觉还蛮真实的~（不过有的地方真的写得有点太轻浮了吧……嗯……）<br>傻乎乎的也好可爱，不过有时候就显得有点惨。像高远一下子就想到女主没有失去超能力可能是因为她和大家有不一样的地方而不是不喜欢，栖原就想不到……在这条线里，正义侧的管理者们的恶明明白白地展现，利用栖原对人们的爱、透支他的力量，为了他的力量不消失隔离他和女主，真的好惨，是会怀疑有没有进BE的程度。<br>不过我真的很喜欢愿意看写亲情的乙游！感觉男女主除了爱情一无所有是很可悲的。</p><h4 id="c-新記ミハヤ"><a href="#c-新記ミハヤ" class="headerlink" title="c. 新記ミハヤ"></a>c. 新記ミハヤ</h4><p>这个我也蛮喜欢的！（差不多就说完我喜欢的三个角色了……）<br>被工具人同学们称之为超级不亲切的存在…实际上也没觉得不亲切，后面玩了觉得和学生会长比起来简直不值一提（）就是那种普通人男高中生，没有什么离谱的才能，虽然说话不是很有礼貌……但是也不是忍受不了的程度……走近了逐渐了解到作为记者的父母与他的羁绊与最后一次的出游。父亲把防护服给他，然后他看着父母的生命流逝。</p><h4 id="d-間宮アユム"><a href="#d-間宮アユム" class="headerlink" title="d. 間宮アユム"></a>d. 間宮アユム</h4><p>这条感觉男女主都有点难以理解：小鸟游多管闲事（明明几乎是不认识的关系，一次又一次对间宫背后扔礼物的行为好为人师…主要是这个事情，虽然不怎么好，但是也不是非管不可的道德问题，对送礼物的人本人也没什么影响啊…。)，而且在被明确排斥之后还是不依不挠试图改变男主…；间宫冷漠于一切&lt;他人&gt;的存在、以偏执的方式守护着妹妹（背着妹妹插手妹妹的交友），对女主也是言语行为都暴力，这种焦躁甚至涉及到出任务的时候攻击毫无防备的小鸟游……<br>两个极品……<br>还有剧本娘是不是对什么受欢迎的男高中生人设有很大的执念啊……（汗）<br>之后慢慢地解释了间宫家离谱的过往，不在爱而是在实验的心态中诞生的兄妹、也因而产生特殊的羁绊。アユム对妹妹以外的一切其实都是几乎冷漠的，只有妹妹是最重要的，在支线结局里，为了妹妹不踏上自己的道路、为了保留自己的超能力，对女主和对自己都残忍地做出疏离的选择。也不是对二次元攻略对象要求不能有什么关系很好的姐姐妹妹女性亲属那种狭隘的想法，只是纯粹的对这种已经存在的病态的依恋的亲情感到排斥罢了……而且对妹妹爱得病态，对女朋友大概率也是正常不到哪去（）是二次元都不愿意想象的程度。</p><hr><p><strong>悪の正義ルート</strong></p><h4 id="e-日向"><a href="#e-日向" class="headerlink" title="e. 日向"></a>e. 日向</h4><p>感觉家暴男（小声）……曾经是有点懦弱有点自卑的年轻研究员，一直被同事霸凌，在一次出任务发生危险时作为诱饵被同事无情抛弃了连求援都没喊，之后被雪波给救了……惨真的好惨啊。<br>但是因为这个对所有人类都满心恨意是不是有点离谱啊？？还有，对人类满心恨意的你对女主90%时间友好（剩下10%是女主试图说服他动摇了他的时候，他会直接气的冒火）是怎么回事啊（那个时候你们都不熟呢……）女主也真是个圣母小天使对他不离不弃呢（……）<br>能感觉到剧本娘想刻画他暴躁之外人妻（？）的一面，比如做饭啊打扫卫生啊什么的，可是我真的很讨厌暴力分子，把所有不满都诉诸言语和行为的暴力的都是纯纯的白痴……<br><strong>讲不通，洗不白，和女主的恋爱推进也不明不白</strong>，全程问号没从我头顶消失过……而且我觉得不管什么原因，最起码伤害了无辜的人就应该付出代价的（至少表达深刻歉意和补偿的意愿吧）……</p><h4 id="f-雪波"><a href="#f-雪波" class="headerlink" title="f. 雪波"></a>f. 雪波</h4><blockquote><p>：打架好好玩啊！鲨人好好玩啊！好新奇好有趣好开心！<br>：你在看哪里？来和我一起玩呀！因为伊吹说了不能杀掉你我不会杀掉你的哦<br>：亲友是什么？伙伴是什么？花是为什么开？<br>：好寂寞……如果不打架的话他们会爱我吗、</p></blockquote><p>……雪波你……伊吹！你怎么教的孩子！你说句话呀！（）<br>问题和日向差不多同理，孩子好惨，但是冷静下来以后觉得接受不能。（不过他真的长得好可爱）</p><h4 id="g-伊吹"><a href="#g-伊吹" class="headerlink" title="g. 伊吹"></a>g. 伊吹</h4><p>战斗力天花板（仰望）全线的目标就是让伊吹对人类有归属感，然后伊吹就会放弃把所有人类都变成怪兽。因为女主是被他认同的、某种意义上的同类，所以她的话他都会很认真地听……女主就这样莫名其妙的背负上了从伊吹手里拯救人类的任务（）好危险的男的（擦汗）<br>应该是魔法少女化以后声音风格最一致的，这一点超喜欢！（女主每一条线都要问一次伊吹和魔法少女伊吹是不是同一个人觉得有点无聊了……）<br>不得不说，恶侧的所有感情线的剧本水平几乎都可以称之为***……伊吹也差不多。……<br>或者说我觉得女主和这几个根本就还没有机会产生什么那么亲密的感情啊……</p><h4 id="h-冨司リョウ"><a href="#h-冨司リョウ" class="headerlink" title="h. 冨司リョウ"></a>h. 冨司リョウ</h4><p>神秘主义，空降外敌，莫名其妙，莫名其妙，莫名其妙，莫名其妙，毫无铺垫，毫无铺垫，毫无铺垫，毫无铺垫，你…<br>不想写可以不写的。</p><h3 id="3-总评"><a href="#3-总评" class="headerlink" title="3. 总评"></a>3. 总评</h3><p>a. 虽然有很多不错的角色设计，作为乙女游戏写不好情感发展是硬伤啊……</p><p>b. 虽然有新奇而且还算自洽的世界观，分了9条线讲每次女主都要重新认识一遍真相，推进速度慢而且冗长（就是说，即使是乙女游戏也没有必要把它的所有男角色都设置成可攻略？也不一定参与大事的都非得是男角色？）</p><p>c. 非常吸引人的魔法少女化是大萌点也是<strong>大雷点</strong>，不仅是男高们变成魔法少女以后cv变了语气和人设也会跟着变，造成的是无法忽视的割裂感</p><p>d. 一些可能无关的讨论：<br>先不考虑怎么做基因实验能把人变成怪兽……（真的很诡异，我觉得唯一能合理解释的角度应该是发现有些动物变异然后用那些动物基因改造人体产生有代价的超能力，而且你们这些个超能力跨度也太离谱了吧，女性化好像是衣服一起变可是这个衣服又可以拆卸（见会长支线结局）我就是不是很理解……明明是魔法就不要跟我谈科学了.jpg）</p><p>如果没有几乎自我意识和思考的怪兽是人变的，那应该怎么对待他们啊……我觉得剧本娘自己都没把事情想明白就匆匆地把疑问又转移给我们。……为了更容易理解，就说人类变成豪猪吧（）——，然后像伊波和女主这种特例呢，他们就是很好地在人类和怪兽之间的存在，犹豫啊犹豫啊，人变成豪猪是人的错误啊我们怎么能伤害豪猪……</p><p>我：……我要是变成豪猪你还是当我死了吧.jpg<br>可以看到剧本娘一直希望表达怪兽有一些情感来发挥她极强的同情心同理心，恶侧不断地强调：怪兽们也有感情哦<del>它们和谐的生活着</del>……但是一旦把怪兽用我们更熟悉的一些没有理性、只有本能的动物去替换，就会觉得整个故事的逻辑怎么看都有点怪异……</p><p>其实就是说，只要你这个怪兽它是没有自我意识的，它差不多就是我们人类视角下类似什么牲畜啊之类的东西，我们吃猪牛羊肉的时候也不想这么多啊。</p><p>而且还有一个问题，影响到伊波理想的&lt;豪猪们和和美美地在被污染的土地上平静生活&gt;的画面<br>你这怪兽，它能不能繁殖啊？（……）</p><p>附一张大团圆CG</p><p><img src="/../../../assets/2022112009053900.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../../assets/2022112009061000.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;无剧透篇&quot;&gt;&lt;a href=&quot;#无剧透篇&quot; class=&quot;headerlink&quot; title=&quot;无剧透篇&quot;&gt;&lt;/a&gt;无剧透篇&lt;/h2&gt;&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Sakura" scheme="https://aleryxiao.github.io/categories/Tavg/Sakura/"/>
    
    
  </entry>
  
  <entry>
    <title>僕と彼の危険な同居生活</title>
    <link href="https://aleryxiao.github.io/Tavg/Rose/79b50c37.html"/>
    <id>https://aleryxiao.github.io/Tavg/Rose/79b50c37.html</id>
    <published>2022-11-06T02:24:58.000Z</published>
    <updated>2023-01-02T19:08:04.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h3><p><img src="/../../../assets/2022110613193900.jpg"></p><ul><li><p>简评：白莲花男主的异国历险记！</p></li><li><p>标签：现代&#x2F;黑道(?)</p></li><li><p>推荐：2&#x2F;5</p></li><li><p>篇幅：极短篇（6h）</p></li><li><p>背景：</p><blockquote><p>努力通过了考试，前往美国留学的日向，刚踏上异国的土地就接二连三地遇上坏事。提前联系好要租的房子只是泡影，去了学校报到却发现自己的名额早被别人注册，顶着自己名字的不明黑发男生招摇地和同学们嬉闹。——该怎么办才好？</p></blockquote></li><li><p>注意：</p><ul><li>非全配音！只有少量的关键剧情有配音，绝大多数都是哼哼唧唧+そうだ+わがった+ごめんなさい…（已经听麻了…）</li><li>不打折不要买！<del>打折了也最好不要买（）</del>剧情比较平淡和俗套，感觉不值得</li><li>NE比较麻烦，建议是NE的tag全选、在最后的分叉点存档，懒得点的姐妹可以私信我直接要走全CG图包 <em>（参考全通攻略（cv17343293 @谷和合盒）</em></li><li>确保先推<strong>亚连</strong>再推<strong>查德</strong>线ww</li></ul></li></ul><h3 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h3><ol><li><p>本着买都买了打了算了、打都打了打完算了的想法硬着头皮打完了，只能说……嗯……<del>（什么作品都能汉化吗）</del><br>了解到这个还是看到阿b姐妹的实况有点好奇，结果实际玩下来体验相当糟糕，好在没有全配音但是有中字让我可以毫不顾忌的一直点点点快速把它看完。<br>下面尽可能地解释一下我的感受。</p></li><li><p>各角色</p><ol><li><p>亚连：<br> 从校门口捡到了手足无措的日向，然后就试着帮他调查整个事件，中间碰到他哥哥对亚连纠缠不休（……），自然而然地发现了哥哥和事件的牵扯，最后在家族组织传统的和哥哥打一架中结束。<br> 故事还是比较完整的，也挺简单的……虽然剧本极力暗示亚连有残忍的一面，说亚连捡各种人回合租房替他挡灾，但是实在是看不出来，感觉就是写了一个挺温柔挺普通的一个会打架的人（……），说不上立体……</p></li><li><p>查德：<br> 应该是剧本刻画的最用心的角色了（）在各条线都不断地强调他身为愉快犯的存在……大概意思就是：很牛逼想要做什么都能做到！在各种危机面前都游刃有余、对一切情况都胸有成竹！只是想做有趣的事情！（）<br> 其实单这么讲感觉挺虚浮的，因为想有理有据地刻画一个这样的角色其实难度很大，靠这点单薄的剧情很难让人信服……还是有点标签大于事实的感觉。<br> 有姐妹说到皇树、、啊、、感觉和皇树有那么点共通吧，可能是剧本娘xp，但是这个根本就没有皇树写的细也没那么有张力啊（悲）虽然感觉查德有点那么pua的意思，但是因为剧情也好角色也好都写得太单薄了、、何も感じないよ……</p></li><li><p>布莱德：<br> 可能算三个人里感觉比较亲切的（）前面一个是杀手组织继承人，一个是聪明绝顶玩世不恭的愉快犯，这位就算是个什么……虽然是混混但是是个温柔有良知的混混，因为悲惨的家庭被迫加入黑帮。应该算描绘的背景最完整的，因为亚连不知道和哥哥到底有什么羁绊（剧本娘多写两段插叙很难吗？……），查德根本就不知道来头……但是想来想去也很奇怪，黑帮之所以是黑帮难道就是干点温柔的事情吗（）没有感觉到符合身份的角色特质……可以像左马刻讲讲明白也很好啊（）</p></li><li><p>日向：<br> 我的天我今年20岁为什么还在看我10岁刚开始看言情小说的时候能看到的小白花女主角形象……一边玩一边叹气，十次叹气五次是为你，我的圣母男主，就不提明明是男孩子但是完全没有表现出男孩子特质（换个性别真的毫无问题……）还反复在一些情境下说“可是我是男的呀~”之类的下头话（），在性命刚被威胁完的情况阻止布莱德掰断对方拿刀的手（…），明明什么都做不到却什么都想拯救只会成为对别人的道德绑架啊……看得好痛苦……<br> 一句话就是在刻画角色方面还是有硬伤，主要是在强行附加一些标签，没有达到让人共情的程度，看完两个小时剧情还是对人物没什么概念，剧本娘也很吝啬于讲述人物的性格细节，处处透露着漫不经心（）。</p></li></ol></li><li><p>索然无味的白开水和可能有缺陷的鸡尾酒，选哪个？<br> 本来想尽可能客观和冷静但是一旦碰到键盘我还是觉得好生气，可是过两天可能我就根本不想提这一部了，所以趁着还想写赶紧骂完（）。<br> 本作就可以说是白开水了，我好久没有打到这么索然无味的作品了，在像白开水一样无聊的剧情的基础上是单薄的攻略对象和始终一副无辜的惨状的小白花男主，（泪），只能说CG还算好看、为数不多的配音也蛮好听。相比来说，同班底的女王蜂在人物刻画上做的要显著好很多，（虽然也有很多很多不满意的地方x），尤其是两个女主角，都很有各自的特点，剧情虽然有很多地方经不起多想但是至少不会让人觉得没兴趣往下玩啊，甚至细细推敲还有点对动物性的思考的意思。<br> 真的好生气！赶紧去玩下一部了！（qwq</p></li></ol>]]></content>
    
    
    <summary type="html">2/5 白莲花男主的异国历险记！</summary>
    
    
    
    <category term="Tavg" scheme="https://aleryxiao.github.io/categories/Tavg/"/>
    
    <category term="Rose" scheme="https://aleryxiao.github.io/categories/Tavg/Rose/"/>
    
    
  </entry>
  
  <entry>
    <title>电脑buy</title>
    <link href="https://aleryxiao.github.io/Collage/ea967099.html"/>
    <id>https://aleryxiao.github.io/Collage/ea967099.html</id>
    <published>2022-10-31T09:19:36.000Z</published>
    <updated>2023-01-02T14:07:00.646Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../assets/QQ%E6%88%AA%E5%9B%BE20220921080411.png"></p><p><img src="/../../assets/QQ%E6%88%AA%E5%9B%BE20220921080357.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../assets/QQ%E6%88%AA%E5%9B%BE20220921080411.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../assets/QQ%E6%88%AA%E5%9B%BE20220921080357.png&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Collage" scheme="https://aleryxiao.github.io/categories/Collage/"/>
    
    
    <category term="装机" scheme="https://aleryxiao.github.io/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Syncthing的ignore忽略规则配置说明</title>
    <link href="https://aleryxiao.github.io/Engineer/850c9066.html"/>
    <id>https://aleryxiao.github.io/Engineer/850c9066.html</id>
    <published>2022-10-30T02:26:43.000Z</published>
    <updated>2023-01-03T05:22:59.591Z</updated>
    
    <content type="html"><![CDATA[<p>#群晖 #Syncthing</p><hr><ul><li><a href="https://blog.csdn.net/XiaoXiao_RenHe/article/details/114283983">https://blog.csdn.net/XiaoXiao_RenHe&#x2F;article&#x2F;details&#x2F;114283983</a></li><li>Syncthing服务器间文件同步，忽略规则配置说明</li><li>2022-07-17 09:51:14</li></ul><hr><p>Syncthing服务器间文件同步时，若根目录下子目录或文件不想同步时，可以配置忽略规则。</p><p>如下截图，表示根目录&#x2F;Apache下<strong>所有</strong>名称为temp、glowroot的文件夹不进行同步。</p><p><img src="/../../../assets/20210302190914346-20220717095114-0jc52ip.png"></p><p>说明：</p><p>0、匹配规则仅仅是如何匹配，若要匹配文件夹&#x2F;目录&#x2F;子目录时，忽略模式中最后不能写&#x2F;，写了&#x2F;的表示匹配目录下的子目录&#x2F;文件。</p><pre><code>  **请注意，以斜杠结尾的目录模式some/directory/与目录内容匹配，但与目录本身不匹配。如果希望模式与目录及其内容匹配，请确保模式末尾没有/。**</code></pre><p>1、配置忽略模式时，  <strong>忽略规则都是基于文件根目录的</strong> ，根目录如下图所示：</p><p>2、以** &#x2F;&#x2F; **开始的行，表示该行是 <strong>注释</strong> ，不是忽略规则。</p><p>3、 <strong>文件夹&#x2F;目录名称</strong> （如temp）匹配——忽略根目录下<strong>所有</strong>该文件夹&#x2F;目录&#x2F;子目录，即服务器间同步时，配置的该文件夹&#x2F;目录（temp）不进行同步。</p><p>4、***** 匹配符——匹配 任意个字符，但不包含目录分隔符 \ ，如te*p，可以匹配temp、teatop、tep等，但不匹配templete\pool。</p><p>5、****** 匹配符——匹配任意个字符，且包含目录分隔符 \ 。</p><p>6、<strong>？</strong> 匹配符——  <strong>一个？匹配一个字符，且不包含目录分隔符 \ </strong> 。</p><p>7、 <strong>[ ]</strong> 匹配符——  <strong>一个[ ]匹配一个区间内的字符，</strong> 如[a-c]，即这个字符可以是a或b或c。</p><p>8、 <strong>{}</strong> 匹配符——匹配{}中以逗号分隔的<strong>一个</strong>内容，如{banana,pineapple}，即可以匹配到banana或pineapple。</p><p>9、 \ 转义符 ——特殊符号（如：<em>、&#x2F; 、\、</em>、？、[、]、{、}），匹配规则需要特殊匹配时，可以使用到转义符，如<code>\&#123;banana\&#125;可以匹配到&#123;banana&#125;</code> ，当前windows系统不支持。</p><p>10、 <strong>&#x2F;Apache</strong> ——只在根目录下匹配，即Apache若为子目录，则匹配不到。</p><p>11、 <strong>#include more-patterns.txt</strong> ——可以引用外部的规则文件，但是模式本身仍然是相对于文件夹根目录的，且文件不存在或重复引用会报错。</p><p>12、 <strong>！</strong> 匹配符——即大规则下某些文件夹&#x2F;目录&#x2F;文件需要同步，！时需要强制扫描整个目录树，但！&#x2F;Apache不会强制扫描整个目录树。</p><p>13、 <strong>(?i)</strong> 匹配符——即后面的内容不区分大小写来进行匹配。</p><p>14、 <strong>(?d)</strong> 匹配符——即删除文件夹&#x2F;目录时，若文件夹&#x2F;目录下有被组织删除的文件，可以使用该前缀，表示可被允许删除的文件。</p><p>注意：(?d)(?i)可以部分前后进行匹配。</p><p><img src="/../../../assets/20210302141615445-20220717095114-yi9m1rg.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#群晖 #Syncthing&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/XiaoXiao_RenHe/article/details/114283983&quot;&gt;https://blog.csdn.net/XiaoXiao_</summary>
      
    
    
    
    <category term="Engineer" scheme="https://aleryxiao.github.io/categories/Engineer/"/>
    
    
  </entry>
  
  <entry>
    <title>RaiDrive 实现挂载阿里云盘到本地 并且 开机自启动</title>
    <link href="https://aleryxiao.github.io/Engineer/c2b8d766.html"/>
    <id>https://aleryxiao.github.io/Engineer/c2b8d766.html</id>
    <published>2022-10-30T02:26:19.000Z</published>
    <updated>2023-01-03T05:22:53.655Z</updated>
    
    <content type="html"><![CDATA[<hr><p> <a href="https://blog.csdn.net/weixin_42795002/article/details/121864236?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-121864236-blog-121243977.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-121864236-blog-121243977.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=5">link</a></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　关于挂载阿里云盘到本地网络上有很多种办法，大同小异，这里只是自己推荐一种办法。此办法是利用 <a href="https://www.raidrive.com/">RaiDrive</a> 和 <a href="https://github.com/zxbu/webdav-aliyundriver">webdav-aliyundriver</a> 在将其安装到服务中，进行开机自启动，并不会感受到任何弹窗情况。个人使用阿里网盘体验感觉还行，百兆移动宽带，直接播放百兆视频也就缓冲一会就可以播放</p><h2 id="第一步：准备软件"><a href="#第一步：准备软件" class="headerlink" title="第一步：准备软件"></a>第一步：准备软件</h2><p>　　首先我们要准备三款软件，作者已经打包基本配置好，方便直接下载。</p><ol><li>点击软件包 并 解压 可跳过 2、3、4 步骤。<a href="https://download.csdn.net/download/weixin_42795002/60316486">&#x3D;&#x3D;此处进行下载&#x3D;&#x3D;</a>软件包中包含内容如下</li></ol><blockquote><p>webdav-aliyundriver-2.4.2.exe 对应是 WinSW<br>webdav-aliyundriver-2.4.2.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a> 对应是 WinSW 的配置文件<br>webdav-aliyundriver-2.4.2.jar 对应是 webdav-aliyundriver<br>这里为了大家使用方便，所以提前修改好了名称<br>raidrive-2021-10-9.exe 直接双击安装好后，即可删除掉安装包，其余不可删除</p></blockquote><p>　　<img src="/0e7a912e77744b749f72e88637bce288-20220809113607-fwb5w68.png" alt="在这里插入图片描述">​</p><ol start="3"><li><a href="https://www.raidrive.com/">RaiDrive</a> 点这里进如官网下载最新版本安装即可</li><li><a href="https://github.com/zxbu/webdav-aliyundriver">webdav-aliyundriver</a> 点这里进如Github 下载最新版本安装即可</li><li><a href="https://github.com/winsw/winsw/releases">WinSW</a> 点这里进如Github 下载最新版本安装即可</li></ol><h2 id="第二步：安装软件"><a href="#第二步：安装软件" class="headerlink" title="第二步：安装软件"></a>第二步：安装软件</h2><blockquote><p>如果下载了作者准备的软件包可跳过 本小节的 <strong>步骤二</strong> 安装配置 webdav-aliyundriver 和 WinSW ，直接到 <strong>第三步：配置和启动</strong></p></blockquote><h3 id="1、RaiDrive-安装"><a href="#1、RaiDrive-安装" class="headerlink" title="1、RaiDrive 安装"></a>1、RaiDrive 安装</h3><p>　　双击选着语言和安装目录，直接安装即可。</p><h3 id="2、安装配置-webdav-aliyundriver-和-WinSW"><a href="#2、安装配置-webdav-aliyundriver-和-WinSW" class="headerlink" title="2、安装配置 webdav-aliyundriver 和 WinSW"></a>2、安装配置 webdav-aliyundriver 和 WinSW</h3><p>　　在任意目录创建一个文件夹，这里在D盘创建名为 aliyundriver 文件夹做演示<br> <img src="/ea14ec1566094cc18857dab68c06e032-20220809113607-xzok9sg.png" alt="创建aliyundriver 文件夹"><br> 将下载的 webdav-aliyundriver 和 WinSW 放到 aliyundriver 目录中，如图所示：</p><blockquote><p>webdav-aliyundriver 是 jar文件<br>WinSW 是 exe 可执行文件<br>这里如图所示，将两个文件的名称修改保持一致</p></blockquote><p>　　<img src="/7aa926b069b242a98efcd613ae097040-20220809113607-75dymle.png" alt="放置webdav-aliyundriver 和 WinSW文件">​</p><h2 id="第三步：配置和启动"><a href="#第三步：配置和启动" class="headerlink" title="第三步：配置和启动"></a>第三步：配置和启动</h2><blockquote><p>如果使用软件包，修改软件包中 webdav-aliyundriver-2.4.2.xml 文件<br>修改 –aliyundrive.refresh-token 的值 即可，token 获取办法看 本小节的 获取阿里云盘自己账号的 refreshToken<br><img src="/4a7ba8c7e274480e933dbb1dd1a63185-20220809113607-05ve335.png" alt="修改TOKEN"></p></blockquote><h3 id="1、获取阿里云盘自己账号的refreshToken"><a href="#1、获取阿里云盘自己账号的refreshToken" class="headerlink" title="1、获取阿里云盘自己账号的refreshToken"></a>1、获取阿里云盘自己账号的refreshToken</h3><p>　　点此处 <a href="https://www.aliyundrive.com/drive/">登录</a> 阿里云盘 账号</p><p>　　登录成功后，按F12 打开 开发者人员工具 按照如图 所示 找到 token<br> <img src="/assets/6d8c8e47de864d429cf6eaf4e82a7ac0-20220809113607-y2dac8g.png" alt="查找token"><br> 将 自己的 refreshToken 值复制下来<br> <img src="/assets/ca87103f330543fb8f697736588c562d-20220809113607-z9zoj0b.png" alt="refreshToken "></p><h3 id="2、创建和配置xml-如果使用软件包，无需操作此步"><a href="#2、创建和配置xml-如果使用软件包，无需操作此步" class="headerlink" title="2、创建和配置xml (如果使用软件包，无需操作此步)"></a>2、创建和配置xml (如果使用软件包，无需操作此步)</h3><p>　　在 自己创建的 aliyundriver 目录中，创建 和其它文件名称相同的文件，打开后将下方的代码复制到文件中并修改 –aliyundrive.refresh-token 的值 即可<br> <img src="/assets/aafa59d0ab314ea9b644d1f52a7a11a7-20220809113607-92q7ese.png" alt="创建和配置xml"></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- ID of the service. It should be unique across the Windows system--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>webdav-aliyundriver<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Display name of the service --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>webdav-aliyundriver<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Service description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>webdav-aliyundriver<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- Path to the executable, which should be started --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executable</span>&gt;</span>java<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">       aliyundrive.refresh-token 填写TOKEN</span></span><br><span class="line"><span class="comment">       server.port 填写端口</span></span><br><span class="line"><span class="comment">       这里出于避免与其它服务冲突将其默认8080修改为8181，当然你也可以修改成自己的端口 </span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arguments</span>&gt;</span>-jar webdav-aliyundriver-2.4.2.jar --aliyundrive.refresh-token=&quot;填写TOKEN&quot;  --server.port=&quot;8181&quot; --aliyundrive.auth.enable=true --aliyundrive.auth.user-name=&quot;admin&quot; --aliyundrive.auth.password=&quot;admin&quot;<span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    OPTION: onfailure</span></span><br><span class="line"><span class="comment">    Defines a sequence of actions, which should be performed if the managed executable fails.</span></span><br><span class="line"><span class="comment">    Supported actions: restart, reboot, none</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">onfailure</span> <span class="attr">action</span>=<span class="string">&quot;restart&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;10 sec&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">onfailure</span> <span class="attr">action</span>=<span class="string">&quot;restart&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;20 sec&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    OPTION: resetfailure</span></span><br><span class="line"><span class="comment">    Time, after which the Windows service resets the failure status.</span></span><br><span class="line"><span class="comment">    Default value: 1 day</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resetfailure</span>&gt;</span>1 hour<span class="tag">&lt;/<span class="name">resetfailure</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    OPTION: priority</span></span><br><span class="line"><span class="comment">    Desired process priority.</span></span><br><span class="line"><span class="comment">    Possible values: Normal, Idle, High, RealTime, BelowNormal, AboveNormal</span></span><br><span class="line"><span class="comment">    Default value: Normal</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">priority</span>&gt;</span>Normal<span class="tag">&lt;/<span class="name">priority</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    OPTION: stoptimeout</span></span><br><span class="line"><span class="comment">    Time to wait for the service to gracefully shutdown the executable before we forcibly kill it</span></span><br><span class="line"><span class="comment">    Default value: 15 seconds</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">stoptimeout</span>&gt;</span>15 sec<span class="tag">&lt;/<span class="name">stoptimeout</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    OPTION: stopparentprocessfirst</span></span><br><span class="line"><span class="comment">    If set, WinSW will terminate the parent process before stopping the children.</span></span><br><span class="line"><span class="comment">    Default value: false</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">stopparentprocessfirst</span>&gt;</span>false<span class="tag">&lt;/<span class="name">stopparentprocessfirst</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      OPTION: startmode</span></span><br><span class="line"><span class="comment">      Defines start mode of the service.</span></span><br><span class="line"><span class="comment">      Supported modes: Automatic, Manual, Boot, System (latter ones are supported for driver services only)</span></span><br><span class="line"><span class="comment">      Default mode: Automatic</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startmode</span>&gt;</span>Automatic<span class="tag">&lt;/<span class="name">startmode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">waithint</span>&gt;</span>15 sec<span class="tag">&lt;/<span class="name">waithint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sleeptime</span>&gt;</span>1 sec<span class="tag">&lt;/<span class="name">sleeptime</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">log</span> <span class="attr">mode</span>=<span class="string">&quot;roll-by-size&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sizeThreshold</span>&gt;</span>10240<span class="tag">&lt;/<span class="name">sizeThreshold</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keepFiles</span>&gt;</span>8<span class="tag">&lt;/<span class="name">keepFiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">log</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869</span><br></pre></td></tr></table></figure><h3 id="3、安装服务并启动"><a href="#3、安装服务并启动" class="headerlink" title="3、安装服务并启动"></a>3、安装服务并启动</h3><p>　　以管理员方式 打开 命令行窗口<br> <img src="/056798677be14713bc4b097d6c31b7a5-20220809113607-00k2cr0.png" alt="CMD">​</p><p>　　使用 cd 命令 进入 自己创建的 aliyundriver 目录 或者 进入下载的软件包 解压后 放置的位置，比如这里是放到D盘下 D:\Program Files\aliyundriver 目录中<br> <img src="/assets/e14f16bbcb8a49b5a0529a93322b58b6-20220809113607-617fg65.png" alt="进入目录"><br> 确保是以管理方式进入后，执行如下命令：</p><blockquote><p>webdav-aliyundriver-2.4.2 此处切记要和你修改的名称一致</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">webdav<span class="literal">-aliyundriver-2</span>.<span class="number">4.2</span>.exe install</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>　　这里已经执行过一次，所以提示已经存在，首次安装会提示安装成功<br> <img src="/assets/3ba475c0c8e04531969923271b467348-20220809113607-1oogz8c.png" alt="安装服务"><br> 然后执行如下命令启动服务</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net <span class="built_in">start</span> webdav<span class="literal">-aliyundriver</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>　　<img src="/assets/9772646fb882417898613d581882eaf2-20220809113607-b7786dc.png" alt="启动服务">​</p><h3 id="4、启动-RaiDrive-连接-挂载阿里云盘到本地"><a href="#4、启动-RaiDrive-连接-挂载阿里云盘到本地" class="headerlink" title="4、启动 RaiDrive 连接 挂载阿里云盘到本地"></a>4、启动 RaiDrive 连接 挂载阿里云盘到本地</h3><p>　　1、打开 RaiDrive 软件，点击添加<br> <img src="/assets/0a3b917663c945f2a444bbb20f882cf4-20220809113607-zbtg682.png" alt="打开软件">​</p><p>　　2、 根据如图所示，勾选配置</p><blockquote><p>账号和密码 都是 admin<br>8181 是端口<br>地址后面的 选项要去掉，否则会失败<br>盘符 和 名称 根据自己喜好选择和填写</p></blockquote><p>　　<img src="/assets/34c8cbdb551f4d5d8f93575b08eca8c4-20220809113607-ft70qis.png" alt="添加挂载"><br> <strong>最后配置好后，点击连接，既可完成，后续开机启动也会自动连接上</strong></p><p>　　如果哪天不想用了，想卸载了，直接卸载 RaiDrive 软件</p><p>　　在使用命令 卸载 服务</p><blockquote><p>webdav-aliyundriver-2.4.2.exe uninstall</p></blockquote><p>　　停止服务</p><blockquote><p>webdav-aliyundriver-2.4.2.exe stop</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt; &lt;a href=&quot;https://blog.csdn.net/weixin_42795002/article/details/121864236?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevan</summary>
      
    
    
    
    <category term="Engineer" scheme="https://aleryxiao.github.io/categories/Engineer/"/>
    
    
    <category term="群晖" scheme="https://aleryxiao.github.io/tags/%E7%BE%A4%E6%99%96/"/>
    
  </entry>
  
  <entry>
    <title>电脑check</title>
    <link href="https://aleryxiao.github.io/Collage/afc0c454.html"/>
    <id>https://aleryxiao.github.io/Collage/afc0c454.html</id>
    <published>2022-10-30T02:25:53.000Z</published>
    <updated>2023-01-02T14:07:00.647Z</updated>
    
    <content type="html"><![CDATA[<h5 id="检查电池健康度"><a href="#检查电池健康度" class="headerlink" title="检查电池健康度"></a>检查电池健康度</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">powercfg /BatteryReport</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;检查电池健康度&quot;&gt;&lt;a href=&quot;#检查电池健康度&quot; class=&quot;headerlink&quot; title=&quot;检查电池健康度&quot;&gt;&lt;/a&gt;检查电池健康度&lt;/h5&gt;&lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;c</summary>
      
    
    
    
    <category term="Collage" scheme="https://aleryxiao.github.io/categories/Collage/"/>
    
    
    <category term="装机" scheme="https://aleryxiao.github.io/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
</feed>
